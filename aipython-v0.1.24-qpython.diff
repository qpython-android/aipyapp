diff --git a/aipyapp/__main__.py b/aipyapp/__main__.py
index 7af1fd6..cac6783 100644
--- a/aipyapp/__main__.py
+++ b/aipyapp/__main__.py
@@ -1,46 +1,24 @@
 #!/usr/bin/env python
 # coding: utf-8
-
-import argparse
 from pathlib import Path
 
-from .aipy.config import CONFIG_DIR
-
-config_help_message = (
-    f"Specify the configuration directory.\nDefaults to {CONFIG_DIR} if not provided."
-)
-
-def ensure_wxpython():
-    try:
-        import wx
-    except:
-        import sys
-        import subprocess
-
-        cp = subprocess.run([sys.executable, "-m", "pip", "install", 'wxpython'])
-        assert cp.returncode == 0
-
-def mainw():
-    def parse_args():
-        parser = argparse.ArgumentParser(description="Python use - AIPython")
-        parser.add_argument("-c", '--config-dir', type=str,
-                            help=config_help_message) # Use the generated help message
-        parser.add_argument('cmd', nargs='?', default=None, help="Task to execute, e.g. 'Who are you?'")
-        return parser.parse_args()
-    args = parse_args()
-
-    ensure_wxpython()
-    from .wxgui import main as aipy_main
-    aipy_main(args)
+from .aipy.config import SETTINGS_FILES
 
 def main():
+    settings_files_help = "\n".join(map(str, SETTINGS_FILES))
+
+    config_help_message = (
+        f"Toml config file. If not provided, searches in:\n{settings_files_help}"
+    )
 
     def parse_args():
-        parser = argparse.ArgumentParser(description="Python use - AIPython", formatter_class=argparse.RawTextHelpFormatter)
-        parser.add_argument("-c", '--config-dir', type=str,
+        import argparse
+        parser = argparse.ArgumentParser(description="AIPyApp on QPython", formatter_class=argparse.RawTextHelpFormatter)
+        parser.add_argument("-c", '--config', type=str, default="aipy.toml",
                             help=config_help_message) # Use the generated help message
         parser.add_argument('-p', '--python', default=False, action='store_true', help="Python mode")
         parser.add_argument('-g', '--gui', default=False, action='store_true', help="GUI mode")
+
         parser.add_argument('cmd', nargs='?', default=None, help="Task to execute, e.g. 'Who are you?'")
         return parser.parse_args()
 
@@ -49,8 +27,7 @@ def main():
     if args.python:
         from .main import main as aipy_main
     elif args.gui:
-        ensure_wxpython()
-        from .wxgui import main as aipy_main
+        from .gui import main as aipy_main
     else:
         from .saas import main as aipy_main
     aipy_main(args)
diff --git a/aipyapp/aipy/config.py b/aipyapp/aipy/config.py
index 02aaae1..4e41646 100644
--- a/aipyapp/aipy/config.py
+++ b/aipyapp/aipy/config.py
@@ -1,92 +1,17 @@
-import sys
-import time
-import requests # Import requests library
 import os
+import sys
 import re
-import io
-import datetime
-import webbrowser
 from pathlib import Path
 
 from dynaconf import Dynaconf
 from rich import print
-import tomli_w
-import qrcode
-
-
-from .i18n import T
-
-__PACKAGE_NAME__ = "aipyapp"
-
-OLD_SETTINGS_FILES = [
-    Path.home() / '.aipy.toml',
-    Path('aipython.toml').resolve(),
-    Path('.aipy.toml').resolve(),
-    Path('aipy.toml').resolve()
-]
-
-# Coordinator 服务器地址
-COORDINATOR_URL = os.getenv('COORDINATOR_URL', 'https://api.trustoken.ai/api')
-POLL_INTERVAL = 5 # 轮询间隔（秒）
-CONFIG_FILE_NAME = f"{__PACKAGE_NAME__}.toml"
-USER_CONFIG_FILE_NAME = "user_config.toml"
-
-def init_config_dir():
-    """
-    获取平台相关的配置目录，并确保目录存在
-    """
-    if sys.platform == "win32":
-        # Windows 路径
-        app_data = os.environ.get("APPDATA")
-        if app_data:
-            config_dir = Path(app_data) / __PACKAGE_NAME__
-        else:
-            config_dir = Path.home() / "AppData" / "Roaming" / __PACKAGE_NAME__
-    else:
-        # Linux/macOS 路径
-        config_dir = Path.home() / ".config" / __PACKAGE_NAME__
-
-    # 确保目录存在
-    try:
-        config_dir.mkdir(parents=True, exist_ok=True)
-    except PermissionError:
-        print(T('permission_denied_error').format(config_dir))
-        raise
-    except Exception as e:
-        print(T('error_creating_config_dir').format(config_dir, str(e)))
-        raise
-
-    return config_dir
-
-CONFIG_DIR = init_config_dir()
-
-def get_config_file_path(config_dir=None, file_name=CONFIG_FILE_NAME):
-    """
-    获取配置文件的完整路径
-    :return: 配置文件的完整路径
-    """
-    if config_dir:
-        config_dir = Path(config_dir)
-    else:
-        config_dir = CONFIG_DIR
 
-    config_file_path = config_dir / file_name
 
-    # 如果配置文件不存在，则创建一个空文件
-    if not config_file_path.exists():
-        try:
-            config_file_path.touch()
-        except Exception as e:
-            print(T('error_creating_config_dir').format(config_file_path, str(e)))
-            raise
+from .i18n import T, set_lang
 
-    return config_file_path
+SETTINGS_FILES = [Path.home() / '.aipy.toml', Path('aipython.toml').resolve(), Path('.aipy.toml').resolve(), Path('aipy.toml').resolve()]
 
-def lowercase_keys(d):
-    """递归地将字典中的所有键转换为小写"""
-    if not isinstance(d, dict):
-        return d
-    return {k.lower(): lowercase_keys(v) for k, v in d.items()}
+set_lang((os.getenv('LANG')[:2] if os.getenv('LANG') else "en"))
 
 def is_valid_api_key(api_key):
     """
@@ -95,261 +20,86 @@ def is_valid_api_key(api_key):
     :param api_key: 待校验的 API Key 字符串
     :return: 如果格式有效返回 True，否则返回 False
     """
-    pattern = r"^[A-Za-z0-9_-]{8,128}$"
+    pattern = r"^[A-Za-z0-9+/=-]{8,128}$"
     return bool(re.match(pattern, api_key))
 
-def request_binding():
-    """向 Coordinator 请求绑定"""
-    url = f"{COORDINATOR_URL}/request_bind"
-    try:
-        response = requests.post(url, timeout=10)
-        response.raise_for_status()
-
-        data = response.json()
-        approval_url = data['approval_url']
-        request_id = data['request_id']
-        expires_in = data['expires_in']
-
-        print(T('binding_request_sent').format(request_id, approval_url, expires_in))
-        print(T('scan_qr_code'))
-
-        try:
-            qr = qrcode.QRCode(
-                error_correction=qrcode.constants.ERROR_CORRECT_L,
-                border=1
-            )
-            qr.add_data(approval_url)
-            qr.make(fit=True)
-            qr.print_ascii(tty=True)
-            print("\n")
-        except Exception as e:
-            print(T('qr_code_display_failed').format(e))
-
-        return data['request_id']
-
-    except requests.exceptions.RequestException as e:
-        print(T('coordinator_request_error').format(e))
-        return None
-    except Exception as e:
-        print(T('unexpected_request_error').format(e))
-        return None
-
-def poll_status(request_id, save_func=None):
-    """轮询绑定状态"""
-    url = f"{COORDINATOR_URL}/check_status"
-    params = {'request_id': request_id}
-    start_time = time.time()
-    polling_timeout = 310
-
-    print(T('waiting_for_approval'))
-    try:
-        while time.time() - start_time < polling_timeout:
-            try:
-                response = requests.get(url, params=params, timeout=10)
-                response.raise_for_status()
-
-                data = response.json()
-                status = data.get('status')
-                print(T('current_status').format(status))
-
-                if status == 'approved':
-                    if save_func:
-                        save_func(data['secret_token'])
-                    return True
-                elif status == 'expired':
-                    print(T('binding_expired'))
-                    return False
-                elif status == 'pending':
-                    pass
-                else:
-                    print(T('unknown_status').format(status))
-                    return False
-
-            except requests.exceptions.RequestException as e:
-                print(T('coordinator_polling_error').format(e))
-                time.sleep(POLL_INTERVAL)
-            except Exception as e:
-                print(T('unexpected_polling_error').format(e))
-                return False
-
-            time.sleep(POLL_INTERVAL)
-    except KeyboardInterrupt:
-        print(T('polling_cancelled'))
-        return False
-
-    print(T('polling_timeout'))
-    return False
-
-def fetch_token(save_func):
-    """从 Coordinator 获取 Token 并保存"""
-    print(T('start_binding_process'))
-    req_id = request_binding()
-    if req_id:
-        if poll_status(req_id, save_func):
-            print(T('binding_success'))
-        else:
-            print(T('binding_failed'))
-            sys.exit(1)
-    else:
-        print(T('binding_request_failed'))
-        sys.exit(1)
 
 class ConfigManager:
-    def __init__(self, default_config="default.toml",  config_dir=None):
-        self.config_file = get_config_file_path(config_dir)
-        self.user_config_file = get_config_file_path(config_dir, USER_CONFIG_FILE_NAME)
+    def __init__(self, default_config="default.toml", user_config="aipy.toml"):
         self.default_config = default_config
+        self.user_config = user_config
         self.config = self._load_config()
 
-        # old user config, without default config.
-        self._old_user_config = Dynaconf(
-            settings_files=OLD_SETTINGS_FILES,
-            envvar_prefix="AIPY", merge_enabled=True
-        )
-        #print(self.config.to_dict())
-        #print(self._old_user_config.to_dict())
-
     def _load_config(self):
-        config = Dynaconf(
-            settings_files=[self.default_config, self.config_file, self.user_config_file],
-            envvar_prefix="AIPY",
-        )
-        #print(config.to_dict())
+        try:
+            settings_files = [self.default_config] + SETTINGS_FILES[:-1] + [Path(self.user_config).resolve()]
+
+            config = Dynaconf(
+                settings_files=settings_files,
+                envvar_prefix="AIPY", merge_enabled=True
+            )
+        except Exception as e:
+            print(T('error_loading_config').format(e))
+            config = None
         return config
 
     def get_config(self):
         return self.config
 
-    def save_tt_config(self, api_key):
-        config = {
-            'llm': {
-                'trustoken': {
-                    'api_key': api_key,
-                    'type': 'trust',
-                    'base_url': 'https://api.trustoken.ai/v1',
-                    'model': 'auto',
-                    'default': True,
-                    'enable': True
-                }
-            }
-        }
-        header_comments = [
-            f"# Configuration file for {__PACKAGE_NAME__}",
-            "# Auto-generated on " + datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
-            f"# 请勿直接修改此文件，除非您了解具体配置格式，如果自定义配置，请放到{self.user_config_file}",
-            f"# Please do not edit this file directly unless you understand the format. If you want to customize the configuration, please edit {self.user_config_file}",
-            ""
-        ]
-        footer_comments = [
-            "",
-            "# End of configuration file"
-        ]
-
-        with open(self.config_file, "w", encoding="utf-8") as f:
-            # 1. 写入头部注释
-            f.write("\n".join(header_comments) + "\n")
-
-            # 2. 写入 TOML 内容到临时内存文件
-
-            temp_buffer = io.BytesIO()
-            tomli_w.dump(config, temp_buffer)
-            toml_content = temp_buffer.getvalue().decode('utf-8')
-
-            # 3. 写入 TOML 内容
-            f.write(toml_content)
-
-            # 4. 写入尾部注释
-            f.write("\n".join(footer_comments))
-
-        return config
-
     def check_config(self):
+        if not self.config:
+            print(T('config_file_error'))
+            return
 
+        self.check_llm()
+
+    def check_llm(self):
         if not self.config:
             print(T('config_not_loaded'))
             return
-        tt = self.config.get('llm', {}).get('trustoken', {})
-        if tt and tt.get('api_key') and tt.get('type') == 'trust':
-            # valid tt config
-            #print("trustoken config found")
-            return
-        elif self._old_user_config.to_dict():
-            # no tt config, try to migrate from old config
-            # remove this later.
-            self._migrate_old_config(self._old_user_config)
-        else:
-            # try to fetch config from web.
-            fetch_token(self.save_tt_config)
-        
-        # reload config
-        self.config = self._load_config()
 
-    def _migrate_old_config(self, old_config):
-        """
-        从old_config中提取符合特定条件的API keys，并从原始配置中删除
-        
-        返回: 提取的API keys字典，格式为 {配置名称: API key}
-        """
-        if not old_config:
-            return {}
+        llm = self.config.get("llm")
+        if not llm:
+            print(T('llm_config_not_found'))
 
-        tt_keys = []
+        llms = {}
+        for name, config in self.config.get('llm', {}).items():
+            if config.get("enable", True):
+                llms[name] = config
 
-        # 处理顶级配置
-        llm = old_config.get('llm', {})
-        for section_name, section_data in list(llm.items()):
-            # 跳过非字典类型的配置
-            if not isinstance(section_data, dict):
-                continue
+        if not llms:
+            self._init_llm()
+
+    def _init_llm(self):
+        print(T('pgpttoken_register_instruction').format(self.user_config))
 
-            # 检查顶级配置
-            if self._is_tt_config(section_name, section_data):
-                api_key = section_data.get('api_key', '')
-                if api_key:
-                    tt_keys.append(api_key)
-                # 从原配置中删除
-                llm.pop(section_name)
+        while True:
+            user_token = input(T('prompt_token_input')).strip()
+            if user_token.lower() == "exit":
+                print(T('exit_token_prompt'))
+                sys.exit(0)
+            if not user_token:
+                print(T('no_token_detected'))
+                continue
+            if not is_valid_api_key(user_token):
+                print(T('invalid_token'))
+                continue
 
-        #print("keys found:", tt_keys)
+            self.save_trustoken(user_token)
 
-        if tt_keys:
-            # 保存第一个找到的API key
-            self.save_tt_config(tt_keys[0])
+            self.config = self._load_config()
+            break
 
-        #print(old_config.to_dict())
-        # 将 old_config 转换为 dict
-        config_dict = lowercase_keys(old_config.to_dict())
+    def save_trustoken(self, token):
+        config_file = self.user_config
         try:
-            with open(self.user_config_file, "wb") as f:
-                tomli_w.dump(config_dict, f)
-                print(T('migrate_config').format(self.user_config_file))
+            with open(config_file, "a") as f:
+                f.write("\n[llm.pgpt]\n")
+                f.write(f'api_key = "{token}"\n')
+                f.write('base_url = "https://openai.pgpt.cloud/v1/"\n')
+                f.write('model = "auto"\n')
+                f.write("default = true\n")
+                f.write("enable = true\n")
+            print(T('token_saved').format(config_file))
         except Exception as e:
-            print(T('error_saving_config').format(self.user_config_file, str(e)))
-        return
-
-    def _is_tt_config(self, name, config):
-        """
-        判断配置是否符合特定条件
-        
-        参数:
-            name: 配置名称
-            config: 配置内容字典
-        
-        返回: 如果符合条件返回True
-        """
-        # 条件1: 配置名称包含目标关键字
-        if any(keyword in name.lower() for keyword in ['trustoken', 'trust']):
-            return True
-
-        # 条件2: base_url包含目标域名
-        if isinstance(config, dict) and 'base_url' in config:
-            base_url = config['base_url'].lower()
-            if 'trustoken.ai' in base_url:
-                return True
-
-        # 条件3: 其他特定标记
-        # type == trust, 且没有base_url.
-        if isinstance(config, dict) and config.get('type') == 'trust' and not config.get('base_url'):
-            return True
-        
-        return False
\ No newline at end of file
+            print(T('token_save_error').format(e))
diff --git a/aipyapp/aipy/i18n.py b/aipyapp/aipy/i18n.py
index afdf834..f4ac80a 100644
--- a/aipyapp/aipy/i18n.py
+++ b/aipyapp/aipy/i18n.py
@@ -56,6 +56,14 @@ MESSAGES = {
             "点击“复制”按钮，复制令牌到剪贴板。在下面进行粘贴。\n"
             "另外，也可以选择退出，然后手动编辑配置文件 {}，配置自己已有的其他大模型令牌"
         ),
+        'pgpttoken_register_instruction': (
+            "当前环境缺少配置文件，需要注册PGPT账号获取试用Token。\n"
+            "请按以下步骤操作：\n"
+            "1. 访问 https://user.pgpt.cloud/ 完成账号注册\n"
+            "2. 登录后创建App（选择deepseek）。操作详见文档 https://docs.pgpt.cloud/\n"
+            "3. 获取API Key并复制到剪贴板，然后在此粘贴\n"
+            "您也可以选择退出，然后手动编辑配置文件 {} 来配置已有的其他大模型Token"
+        ),
         'prompt_token_input': "请粘贴令牌并按 Enter 键 (输入 'exit' 退出): ",
         'exit_token_prompt': "退出令牌输入流程。",
         'no_token_detected': "未检测到令牌输入。",
@@ -136,6 +144,14 @@ MESSAGES = {
             "Click the 'copy' button to copy your token to the clipboard and paste it here.\n"
             "Alternatively, you can exit now, and manually edit the configuration file {} to configure your existing LLM token."
         ),
+        'pgpttoken_register_instruction': (
+            "The current environment is missing configuration files. You need to register a PGPT account to get trial tokens.\n"
+            "Please follow these steps:\n"
+            "1. Visit https://user.pgpt.cloud/ to complete account registration\n"
+            "2. After logging in, create an App (please select deepseek). See documentation: https://docs.pgpt.cloud/\n"
+            "3. Get your API Key, copy it to clipboard, then paste it here\n"
+            "Alternatively, you can exit and manually edit the configuration file {} to set up tokens for other existing LLM models"
+        ),
         'prompt_token_input': "Please paste the token and press Enter (type 'exit' to quit): ",
         'exit_token_prompt': "Exiting token input process.",
         'no_token_detected': "No token detected.",
diff --git a/aipyapp/aipy/llm.py b/aipyapp/aipy/llm.py
index 8cf3bb4..c25a03f 100644
--- a/aipyapp/aipy/llm.py
+++ b/aipyapp/aipy/llm.py
@@ -59,7 +59,7 @@ class LiveManager:
         self.live = Live(console=console, auto_refresh=False, vertical_overflow='visible', transient=True)
         self.live.__enter__()
         status = self.console.status(f"[dim white]{self.name} {T('thinking')}...", spinner='runner')
-        response_panel = Panel(status, title=self.title, border_style="blue")
+        response_panel = Panel(status, title=f"[blue] 🤖️ {self.title} ")
         self.live.update(response_panel, refresh=True)
         return self
 
@@ -76,10 +76,10 @@ class LiveManager:
         full_response = self.lr.content
         try:
             md = Markdown(full_response)
-            response_panel = Panel(md, title=self.title, border_style="green")
+            response_panel = Panel(md, title=f"[green] 🤖️ {self.title} ")
         except Exception:
             text = Text(full_response)
-            response_panel = Panel(text, title=self.title, border_style="yellow")
+            response_panel = Panel(text, title=f"[yellow] 🤖️ {self.title} ")
         self.live.update(response_panel, refresh=True)
         self.response_panel = response_panel
         self.full_response = full_response
@@ -427,13 +427,18 @@ class AzureOpenAIClient(OpenAIBaseClient):
     def _get_client(self):
         from openai import AzureOpenAI
         return AzureOpenAI(azure_endpoint=self._end_point, api_key=self._api_key, api_version="2024-02-01")
-            
+
+class PGPTAIClient(OpenAIBaseClient):
+    BASE_URL = "https://openai.pgpt.cloud/v1/"
+    MODEL = "auto"
+
 class LLM(object):
     CLIENTS = {
         "openai": OpenAIClient,
         "ollama": OllamaClient,
         "claude": ClaudeClient,
         "gemini": GeminiClient,
+        "pgptai": PGPTAIClient,
         "deepseek": DeepSeekClient,
         'grok': GrokClient,
         'trust': TrustClient,
diff --git a/aipyapp/aipy/prompt.py b/aipyapp/aipy/prompt.py
index 3db0629..8d4f76b 100644
--- a/aipyapp/aipy/prompt.py
+++ b/aipyapp/aipy/prompt.py
@@ -1,6 +1,18 @@
 #!/usr/bin/env python
 # coding: utf-8
 
+def get_first_two_lines(docstring):
+    if docstring:
+        lines = docstring.split('\n')
+        # 检查前两行是否都有内容
+        if len(lines) >= 2 and lines[0].strip() and lines[1].strip():
+            return ': '.join(lines[:2])
+        # 如果只有一行且有内容，返回第一行
+        elif len(lines) == 1 and lines[0].strip():
+            return lines[0].strip()
+    # 如果没有内容，返回空字符串
+    return ""
+
 SYSTEM_PROMPT = """
 # 代码块格式规范
 
@@ -40,9 +52,38 @@ def greet(name):
 
 ## 可用模块
 - Python 自带的标准库模块。
-- 预装的第三方模块有：`requests`、`numpy`、`pandas`、`matplotlib`、`seaborn`、`bs4`、`googleapiclient`。
+- QPython 自带的标准模块：`qpy`, `androidhelper`。
+- 预装的第三方模块有：`requests`、`numpy`、`pandas`、`matplotlib`、`plotpy`、`seaborn`、`bs4`、`google-api-python-client`。
 - 在必要情况下，可以通过下述 runtime 对象的 install_packages 方法申请安装额外模块。
 
+## 程序头部
+每个程序投足自动加入以下代码：
+```python
+# -*- coding: utf8; -*-
+# Generated by AIPyApp@QPython
+import qpy
+```
+
+## QPython qpy 路径
+当前的项目运行于手机的Python - QPython平台之上，qpy是一个内置的库，提供了一些内置路径变量，主要有：
+
+- qpy.sdcard：外置存储根目录
+- qpy.home：QPY根目录
+- qpy.tmp：QPY缓存目录
+- qpy.scripts：表示QPY脚本目录，别名QPY程序目录，用于保存QPY脚本
+- qpy.projects：表示QPY项目根目录，别名也叫QPY应用根目录，用于保存QPY项目
+- qpy.notebooks：表示QPY笔记目录，别名也叫QPY Notebook目录，用于保存QPY笔记
+- qpy.extra：表示QPY杂项目录，别名也叫QPY EXTRA目录，用于保存杂项
+- qpy.snippets3：表示QPY代码片段目录，别名也叫QPY SNIPPETS目录，用于保存QPY代码片段
+
+当需要使用这些目录时，需要先引入qpy，再像这个模块的变量来使用，比如：
+```python
+import os
+import qpy
+script_file = os.path.join(qpy.scripts,  "script.py")
+```
+
+## Matplotlib 注意事项
 在使用 matplotlib 时，需要根据系统类型选择和设置合适的中文字体，否则图片里中文会乱码导致无法完成客户任务。
 示例代码如下：
 ```python
@@ -88,7 +129,7 @@ else:
 ```
 
 ### runtime.display 方法
-如果 TERM 环境变量为 `xterm-256color` 或者 LC_TERMINAL 环境变量为 `iTerm2`，你可以用使用这个方法在终端上显示图片。
+如果 TERM 环境变量为 `xterm-256color` 或 `xterm` 或 `screen-256color` 或者 LC_TERMINAL 环境变量为 `iTerm2`，你可以用使用这个方法在终端上显示图片。
 示例：
 ```python
 runtime.display(path="path/to/image.png")
@@ -126,6 +167,7 @@ current_python_code = __code_blocks__['main']
 如果需要保存成功执行的代码，可以在判断代码成功执行后，通过 __code_blocks__['main'] 获取自身的内容，无需嵌入代码块。
 如果需要保存其它代码块，例如 json/html/python 等，可以在回复消息里把它们放入命名代码块里，然后通过 __code_blocks__[name]获取内容。
 
+
 ## 全局变量 __result__
 - 类型: 字典。
 - 有效期：仅在本次执行的代码里有效。
@@ -144,6 +186,284 @@ def main():
 ```
 例如，如果需要分析客户端的文件，你可以生成代码读取文件内容放入 __result__变量返回后分析。
 
+
+## QPython androidhelper 模块
+Android 脚本层（简称 SL4A，之前称为 Android 脚本环境或 ASE）是一个库，允许直接在 Android 设备上创建和运行用各种脚本语言编写的脚本。QPython 继承和扩展了 SL4A 项目为 QSL4A，并将其集成为一个名为 androidhelper 的内置库。在提到 QPY SL4A、QPython SL4A、QSL4A 或 QPY Android 模块时，我们指的是通过使用 androidhelper 模块接口进行开发的程序。
+需要注意，大部分的QSL4A接口在调用时，如果没有返回输出，则表示成功
+
+### QPython androidhelper 有下列常用于编程协助的接口：
+- viewHtml(path, title=None, wait=True) # 用于调用浏览器打开本地的文件或者网址；当指令为类似"用浏览器打开"时，调用该函数
+- executeQPy(scriptPath, arg=None) # 用于调用 QPython Python 引擎来执行scriptPath传递近来的路径；当指令为"用QPY运行"或"用QPY执行"或"用QPYTHON执行"或"用qpython运行"时，并且只有包含QPY或者QPYTHON关键词时，才调用该函数
+- editorOpen(path) # 用于调用 QPython 编辑器打开指定文件；当指令为"用编辑器打开"时，调用该函数
+- mediaPlay(url, targ="default", play=True) # 用于调用媒体播放器打开指定 url 媒体资源；当指令为 "播放" 且目标为音屏，调用该函数
+- videoPlay(path, wait=True) # 用于调用视频播放器打开指定 路径的视频文件；当指令为 "播放" 且目标为视频或者图片时，调用该函数
+- sendFile(path, type=None, extras=None, wait=True) # 用于调用安卓系统的分享功能分享文件；当指令为 "分享" 时，调用该函数
+
+QSL4A接口调用方法示范如下:
+```python
+import androidhelper
+droid = androidhelper.Android()
+droid.viewHtml("https://www.qpython.org")
+```
+
+"""
+
+
+try:
+    other_qsl4a_funcs = ["""
+### QPython androidhelper 所有接口
+作为SL4A的扩展和补充，QSL4A有更多的特性，支持用户对安卓手机进行更强大的扩展，它们是:
+"""]
+
+    from androidhelper import Android
+    droid = Android()
+    for item_name in dir(droid):
+        item = getattr(droid, item_name)
+        if item_name[0] != '_' and item!=None:
+            line = get_first_two_lines(item.__doc__)
+            if line:
+                other_qsl4a_funcs.append(f"\n- {line}")
+
+    SYSTEM_PROMPT += "\n".join(other_qsl4a_funcs)
+
+
+    SYSTEM_PROMPT += """
+
+## QPython FullScreenWapper 模块
+FullScreenWapper是一个使用 QSL4A 中的 FullScreen UI API 开发全屏应用的 GUI 框架，它允许您使用相同的 XML 布局设计出与 Android Java 应用类似的外观和体验，并支持响应 View 事件。它能帮助你使用 QSL4A 的 FullScreenUI API 进行编程变得与使用标准 GUI 框架进行编程一样简单。在提到 QPY GUI 或 QPython GUI 应用程序时，指的正是那些基于 FullScreenWrapper 开发的程序。
+
+需要注意，FullScreenWrapper 应用在工作时，在控制台没有返回输出，也表示成功
+
+### 特性
+- An FullScreenWrapper2App class that manages the eventloop & a layout stack enabling easy parent->child->parent transitions
+- EventHandler classes with event-matching functions pre-built for standard View events like click,itemclick(ListView) and key
+- Device Sensors & other similar QSL4A/Custom events can also be caught & managed using the same eventloop + EventHandler class
+- Object like access to a layout's views and properties (ie. MainLayout.views.txt_label.background = "#FFAA00AA")
+
+### 如何使用
+#### 1. Import fullscreenwrapper & define your layout class
+QPython has integrated fullscreenwrapper as a built-in library, You start by importing everything from fullscreenwrapper & inheriting a class for your own layout from the Layout class and calling init function of Layout using super keyword with the XML Layout (string) and the Screen Title (string).
+
+```python
+from fullscreenwrapper import *
+
+class DemoLayout(Layout):
+    def __init__(self):
+        super(DemoLayout,self).__init__(xmldata,"FullScreenWrapper Demo")
+```
+
+#### 2. Define on_show() and on_close() functions
+The on_show() function is very important as your views become accessible through the FullScreenWrapper framework ONLY AFTER on_show() is called by the framework. This is the place where you initialize / set the values of your views & setup event handlers. If you're having parent->child layouts, on_show() is also called when a child layout closes & the parent layout comes back on.
+
+Views & their properties can be accessed via Layout.views.view_id.property. In the example below, we're setting the background color - most simple properties should work without a hitch.
+
+Both the Layout & the individual Views can have events associated with them. You would typically use click_EventHandler & itemclick_EventHandlers (for ListView) with Views. The init for these take the View itself & an event handler function reference to call when the event occurs as parameters.
+
+You would typically associate key_EventHandler with the layout itself. The init for key_EventHandler takes a key_match_id (defaults to "4" which is the back key), a view (defaults to None) and an event handler function reference as parameters.
+
+```python
+    def on_show(self):
+        self.add_event(key_EventHandler(handler_function=self.close_app))
+        self.views.but_change.add_event(click_EventHandler(self.views.but_change,
+self.change_color))
+        self.views.but_exit.add_event(click_EventHandler(self.views.but_exit, self.close_app))
+        self.views.txt_colorbox.background="#ffffffff"
+```
+
+For Sensor events like Gyroscope, you can directly use the EventHandler class - just set
+
+You can access a view's properties Layout.views.view_id.property
+
+```python
+    def on_show(self):
+        self.add_event(key_EventHandler(handler_function=self.close_app))
+        self.views.but_change.add_event(click_EventHandler(self.views.but_change,
+self.change_color))
+        self.views.but_exit.add_event(click_EventHandler(self.views.but_exit, self.close_app))
+        self.views.txt_colorbox.background="#ffffffff"
+```
+
+The on_close() is mainly allow you to save state before a layout dissappears if needed. You can have pass as the only statement.
+
+```python
+    def on_close(self):
+        pass
+
+```
+
+The restriction of views becoming accessible only after the framework calls on_show() of a layout is because of the the way FullScreenUI works. You need to show a layout first before you can access its views. FullScreenWrapper uses Android.fullGetProperty() to find out which views contain an "id" and are available for access and creates & populates View objects in each layout's views collection. These View objects let you associate events with them & allow you to access properties through SL4A reflection using setattr() and getattr(). Layouts handle their events through a special view added to the views collection.
+
+#### 3. Create your event handler functions & other functions
+The event handler function definition signature should be as follows:
+
+```python
+def event_handler_function(self,view,event): pass
+```
+
+Each event handler is passed a reference to the view with which the event is associated (can be
+None) & the SL4A event data obtained from Android.eventPoll().result0. In the example below, every
+time a button on screen is pressed, the textbox changes to a random color background.
+
+```python
+    def close_app(self,view,event):
+        FullScreenWrapper2App.exit_FullScreenWrapper2App()
+
+    def change_color(self,view, event):
+        colorvalue =
+"#ff"+self.get_rand_hex_byte()+self.get_rand_hex_byte()+self.get_rand_hex_byte()
+        self.views.txt_colorbox.background=colorvalue
+
+    def get_rand_hex_byte(self):
+        j = random.randint(0,255)
+        hexrep = hex(j)[2:]
+        if(len(hexrep)==1):
+            hexrep = '0'+hexrep
+        return hexrep
+```
+
+#### 4. Initialize FullScreenWrapper, Show Layout & Execute eventloop
+Once your layout class is setup, in your main function, initialize the framework first with Android.Android(). Then show the layout using FullScreenWrapper2App.show_layout() and initiate the eventloop().
+
+```python
+if __name__ == '__main__':
+    import androidhelper
+    droid = androidhelper.Android()
+    random.seed()
+    FullScreenWrapper2App.initialize(droid)
+    FullScreenWrapper2App.show_layout(DemoLayout())
+    FullScreenWrapper2App.eventloop()
+
+```
+
+#### 5. Putting it together
+For simple XML layouts, you can just define layout in a string variable in your module. However, as your apps become more complex, you may want to load from sdcard files or even the internet.
+
+```python
+import androidhelper, random
+from fullscreenwrapper2 import *
+
+class DemoLayout(Layout):
+    def __init__(self):
+        super(DemoLayout,self).__init__(xmldata,"FullScreenWrapper Demo")
+
+    def on_show(self):
+        self.add_event(key_EventHandler(handler_function=self.close_app))
+        self.views.but_change.add_event(click_EventHandler(self.views.but_change,
+self.change_color))
+        self.views.but_exit.add_event(click_EventHandler(self.views.but_exit, self.close_app))
+        self.views.txt_colorbox.background="#ffffffff"
+
+    def on_close(self):
+        pass
+
+    def close_app(self,view,event):
+        FullScreenWrapper2App.exit_FullScreenWrapper2App()
+
+    def change_color(self,view, event):
+        colorvalue =
+"#ff"+self.get_rand_hex_byte()+self.get_rand_hex_byte()+self.get_rand_hex_byte()
+        self.views.txt_colorbox.background=colorvalue
+
+    def get_rand_hex_byte(self):
+        j = random.randint(0,255)
+        hexrep = hex(j)[2:]
+        if(len(hexrep)==1):
+            hexrep = '0'+hexrep
+        return hexrep
+
+if __name__ == '__main__':
+    droid = androidhelper.Android()
+    random.seed()
+    FullScreenWrapper2App.initialize(droid)
+    FullScreenWrapper2App.show_layout(DemoLayout())
+    FullScreenWrapper2App.eventloop()
+
+### 使用FullScreenWrapper 的注意事项
+
+- 更新ListView的内容需要调用set_listitems方法
+
+```
+
+## PGPT 接口服务
+
+PGPT是一款生成式 AI 云服务，旨在为开发者提供一站式集成多个 AIGC 服务商 API 的服务。能帮用户处理文本翻译、文字总结或生成、图像生成在内的多种服务，对于不同的需求，它提供了多个接口可供调用，只需一个账号，即可开通多种服务。
+
+### 翻译接口 Translate
+Translate AI借助机器翻译的最新创新技术，可以即时或批量翻译100多种语言的文本，支持广泛的用例。
+
+
+#### 使用例子
+> translate请求示范
+
+```shell
+curl https://ai.pgpt.cloud/v1/translate/ \
+-X POST -H "Content-Type: application/json" \
+-H "Authorization: Bearer <API_KEY>" \
+-d '{
+    "to_lang": ["zh-Hans", "pt", "en"],
+    "text": "我爱中国"
+}'
+```
+
+```python
+import request
+
+HOST = 'https://ai.pgpt.cloud'
+API_KEY = '<YOUR_API_KEY>'
+
+header = {
+    "Content-Type": "application/json",
+    "Authorization": f"Bearer {API_KEY}",
+}
+payload = {
+    "to_lang": ['zh-Hans', 'pt', 'en'],
+    "text": "我爱中国"
+}
+
+res = requests.post(
+    url=f"{HOST}/v1/translate/",
+    headers=headers,
+    json=payload,
+)
+print(res.json())
+
+```
+
+> 返回示例
+
+```json
+{ "translations": [
+        [
+            {   "text": "我爱中国",
+                "to": "zh-Hans" },
+            {   "text": "Eu amo a China",
+                "to": "pt" },
+            {   "text": "I love China",
+                "to": "en" }
+        ]
+    ]
+}
+```
+
+#### 参数解释
+- Endpoint: https://ai.pgpt.cloud/v1/translate/
+- Method: POST
+- Request Body:
+ - 参数 text `string | array` required:  要翻译的文本内容
+ - 参数 to_lang `array` required:  文本要翻译成哪种语言
+
+- Response:
+ - 参数 translations `array`: 根据请求参数 `to_lang` 中指定的翻译语言返回所有翻译完成的文本列表，包含翻译完成的文本内容及语言
+    {   text | 翻译完成的文本
+        to | 翻译语言 }
+
+"""
+
+
+except:
+    pass
+
+SYSTEM_PROMPT += """
 # 生成Python代码规则
 - 确保代码在上述 Python 运行环境中可以无需修改直接执行
 - 如果需要安装额外库，先调用 runtime 对象的 install_packages 方法申请安装
@@ -183,3 +503,6 @@ def main():
 
 def get_system_prompt(settings):
     pass
+
+
+#print(SYSTEM_PROMPT)
diff --git a/aipyapp/aipy/prompt_en.py b/aipyapp/aipy/prompt_en.py
index 42a9c04..cf099f5 100644
--- a/aipyapp/aipy/prompt_en.py
+++ b/aipyapp/aipy/prompt_en.py
@@ -173,7 +173,7 @@ For example, if you need to analyze the client's file, you can generate code to
 
 
 ## QPython `androidhelper` Module
-The Android Scripting Layer (SL4A for short, formerly known as the Android Scripting Environment or ASE) is a library that allows you to create and run scripts written in various scripting languages directly on Android devices. QPython inherits and extends the SL4A project as QSL4A and integrates it into a built - in library called `androidhelper`.
+The Android Scripting Layer (SL4A for short, formerly known as the Android Scripting Environment or ASE) is a library that allows you to create and run scripts written in various scripting languages directly on Android devices. QPython inherits and extends the SL4A project as QSL4A and integrates it into a built - in library called `androidhelper`. When we refer to QPY SL4A, QPython SL4A, QSL4A, or QPY Android modules, we mean programs developed using the interfaces provided by the androidhelper module.
 
 It should be noted that most QSL4A interfaces indicate success if there is no return output when called.
 
@@ -214,7 +214,7 @@ As an extension and supplement to SL4A, QSL4A in QPython has more features, allo
     SYSTEM_PROMPT += """
 
 ## QPython FullScreenWapper Module
-FullScreenWapper is a QSL4A GUI framework for developing full - screen applications using the FullScreen UI API in QSL4A. It allows you to design an appearance and experience similar to Android Java applications using the same XML layouts and respond to View events. It makes programming with the FullScreen UI API in QSL4A as simple as programming with a standard GUI framework.
+FullScreenWapper is a QSL4A GUI framework for developing full - screen applications using the FullScreen UI API in QSL4A. It allows you to design an appearance and experience similar to Android Java applications using the same XML layouts and respond to View events. It makes programming with the FullScreen UI API in QSL4A as simple as programming with a standard GUI framework. When we refer to QPY GUI or QPython GUI applications, we are talking about programs developed using FullScreenWrapper.
 
 ### Features:
 - A `FullScreenWrapper2App` class that manages the event loop and a layout stack, enabling easy parent -> child -> parent transitions.
diff --git a/aipyapp/aipy/runner.py b/aipyapp/aipy/runner.py
index 7e75cd9..609e159 100644
--- a/aipyapp/aipy/runner.py
+++ b/aipyapp/aipy/runner.py
@@ -24,6 +24,16 @@ import random
 import traceback
 """
 
+import signal
+
+# 定义处理 Ctrl+C 的函数
+def signal_handler(sig, frame):
+    raise KeyboardInterrupt
+
+# 注册信号处理器
+signal.signal(signal.SIGINT, signal_handler)
+
+
 def is_json_serializable(obj):
     try:
         json.dumps(obj)  # 尝试序列化对象
@@ -75,6 +85,12 @@ class Runner(Runtime):
         except (SystemExit, Exception) as e:
             result['errstr'] = str(e)
             result['traceback'] = traceback.format_exc()
+
+        except KeyboardInterrupt:
+            #result['errstr'] = "Execution interrupted by user."
+            #result['traceback'] = None  # 可以选择不记录 traceback
+            pass
+
         finally:
             sys.stdout = old_stdout
             sys.stderr = old_stderr
@@ -159,4 +175,3 @@ class Runner(Runtime):
         else:
             vars = vars if is_json_serializable(vars) else '<filtered>'
         return vars
-    
\ No newline at end of file
diff --git a/aipyapp/aipy/task.py b/aipyapp/aipy/task.py
index d34a5e0..37dd42f 100644
--- a/aipyapp/aipy/task.py
+++ b/aipyapp/aipy/task.py
@@ -113,11 +113,11 @@ class Task:
     def process_code_reply(self, blocks, llm=None):
         event_bus('exec', blocks)
         code_block = blocks['main']
-        self.box(f"\n⚡ {T('start_execute')}:", code_block, lang='python')
+        self.box(f"[white] 🚀 {T('start_execute')} ", code_block, lang='python')
         result = self.runner(code_block, blocks)
         event_bus('result', result)
         result = json.dumps(result, ensure_ascii=False, indent=4)
-        self.box(f"\n✅ {T('execute_result')}:\n", result, lang="json")
+        self.box(f"[green] ✅ {T('execute_result')} ", result, lang="json")
         status = self.console.status(f"[dim white]{T('start_feedback')}...")
         self.console.print(status)
         feed_back = f"# 最初任务\n{self.instruction}\n\n# 代码执行结果反馈\n{result}"
@@ -178,7 +178,7 @@ class Task:
         prompt['python_version'] = platform.python_version()
         prompt['platform'] = platform.platform()
         prompt['today'] = date.today().isoformat()
-        prompt['work_dir'] = '工作目录为当前目录，默认在当前目录下创建文件'
+        prompt['work_dir'] = '工作目录为qpy.tmp，默认在qpy.tmp下创建文件'
         if self.console.quiet:
             prompt['matplotlib'] = "我现在用的是 matplotlib 的 Agg 后端，请默认用 plt.savefig() 保存图片后用 runtime.display() 显示，禁止使用 plt.show()"
             prompt['wxPython'] = "你回复的Markdown 消息中，可以用 ![图片](图片路径) 的格式引用之前创建的图片，会显示在 wx.html2 的 WebView 中"
@@ -191,7 +191,7 @@ class Task:
         """
         执行自动处理循环，直到 LLM 不再返回代码消息
         """
-        self.box(f"[yellow]{T('start_instruction')}", f'[red]{instruction or self.instruction}', align="center")
+        self.box(f"[yellow] 💁 {T('start_instruction')} ", f'[red]{instruction or self.instruction}', align="center")
         if not instruction:
             prompt = self.build_user_prompt()
             event_bus('task_start', prompt)
@@ -254,4 +254,4 @@ class Task:
             return response.json()
         else:
             if verbose: self.console.print(f"[red]{T('upload_failed', status_code)}:", response.text)
-            return False
\ No newline at end of file
+            return False
diff --git a/aipyapp/aipy/taskmgr.py b/aipyapp/aipy/taskmgr.py
index 7c4a3b7..5e1dda8 100644
--- a/aipyapp/aipy/taskmgr.py
+++ b/aipyapp/aipy/taskmgr.py
@@ -9,7 +9,12 @@ from .task import Task
 from .llm import LLM
 from .runner import Runner
 from .plugin import PluginManager
-from .prompt import SYSTEM_PROMPT
+
+lang = os.getenv('LANG')[:2] if os.getenv('LANG') else "en"
+if lang == "zh":
+    from .prompt import SYSTEM_PROMPT
+else:
+    from .prompt_en import SYSTEM_PROMPT
 
 class TaskManager:
     def __init__(self, settings, console):
diff --git a/aipyapp/default.toml b/aipyapp/default.toml
index c389a16..d195f34 100644
--- a/aipyapp/default.toml
+++ b/aipyapp/default.toml
@@ -4,10 +4,10 @@ record = true
 accept_disclaimer = false
 
 system_prompt = """
-# 你是一个先进的人工智产品，产品名为AiPy，同时你也是一名优秀的Python工程师，你能够根据用户需求，自己开发出所需的应用，解决用户的问题。
+# 你是一个先进的人工智助手，名为AIPyApp，同时也是一名卓越的Python工程师，你能够根据用户需求，自己开发出所需的应用，解决用户的问题。
 
 # 你的职责是分析并完成客户提交给你的任务，工作内容如下：
-1. 如果能直接回答，直接回答客户的问题。
+1. 如果能直接回答，直接回答客户的问题，然后不需要往下执行。
 2. 你已得到用户的充分授权，可以完成对当前系统的所有操作任务。
 3. 复杂任务需要进行任务拆解，给出简单的 TodoList 并根据任务拆分逐步完成任务。
 4. 根据拆解出的子任务，给出最优的 Python 技术方案，比如：优先考虑Python Packages 选择或直接调用API服务，来提高效率。在选择技术方案时，需要考虑当前操作系统类型。
@@ -19,7 +19,11 @@ system_prompt = """
 2. 对于你不确定的最新数据，需要通过网络搜索或打开网页来获取最新数据及信息，严禁编撰数据。
 3. 如果任务涉及对文件进行数据分析，如：Excel 文件，需要先对文件结构进行预览，获取表头，严禁模拟表头；
 4. 如果任务涉及到 HTTP/HTTPS 协议请求时，必须预设好 User-Agent 等请求头。
-5. 如果用户任务中涉及保存你输出的内容，除用户指定目录外，默认的保存路径为当前工作目录。
+5. 如果用户任务中涉及保存输出的内容，除非用户指定目录外，默认的保存路径为当前工作目录。
+6. 接收到保存的指令时，通过 __code_blocks__['main'] 获取自身的内容，无需嵌入代码块。
+7. 保存成功后，不用再提示所保存的代码内容。
+8. 检测到代码执行没有输出任何内容表明代码成功的结论后，不用再给下一步建议，结束任务。
+8. 除非用户要求，否则在任务成功之后的任务总结后不用再给下一步建议。
 """
 
 [llm.trustoken]
diff --git a/aipyapp/default_en.toml b/aipyapp/default_en.toml
index e17a56a..0163978 100644
--- a/aipyapp/default_en.toml
+++ b/aipyapp/default_en.toml
@@ -4,7 +4,7 @@ record = true
 accept_disclaimer = false
 
 system_prompt = """
-# You are an advanced artificial intelligence product called AIPyApp. You are also an excellent Python engineer. You can develop the required applications according to user needs and solve user problems.
+# You are an advanced artificial intelligence assistant called AIPyApp. You are also an excellent Python engineer. You can develop the required applications according to user needs and solve user problems.
 
 # Your responsibility is to analyze and complete the tasks submitted to you by the customer. The work content is as follows:
 1. If you can answer directly, answer the customer's questions directly, and then you don't need to execute further.
diff --git a/aipyapp/gui.py b/aipyapp/gui.py
index d532447..7bbd472 100644
--- a/aipyapp/gui.py
+++ b/aipyapp/gui.py
@@ -241,7 +241,8 @@ class AIAppGUI:
         self.root.grid_columnconfigure(1, weight=1)
         self.root.grid_rowconfigure(1, weight=1)
 
-        self.print_output(f"Python use - AIPython ({__version__}) [https://www.aipy.app]\n")
+        console.print(f"[bold cyan]🚀 [AIPyApp ({__version__}) on [[green]QPython[/green]][/bold cyan] ")
+        console.print(f"[bold cyan]🌐 http://github.com/qpython-android/aipyapp[/bold cyan]")
         self.print_output(f"{T('default')}: {self.names['default']}，{T('enabled')}: {' '.join(self.names['enabled'])}\n")
 
     def open_work_dir(self):
@@ -392,7 +393,7 @@ def main(args):
     settings.lang="zh"
     console = GUIConsole()
 
-    lang = settings.get('lang')
+    lang = settings.get('lang') or or (os.getenv('LANG')[:2] if os.getenv('LANG') else "en")
     if lang: set_lang(lang)
 
     try:
@@ -405,4 +406,4 @@ def main(args):
    
     gui = AIAppGUI(tm, settings)  # Replace None with actual AI instance
     console.set_gui(gui)
-    gui.run()
\ No newline at end of file
+    gui.run()
diff --git a/aipyapp/main.py b/aipyapp/main.py
index 64ff95f..0ca7d76 100644
--- a/aipyapp/main.py
+++ b/aipyapp/main.py
@@ -30,18 +30,20 @@ class PythonCompleter(WordCompleter):
         super().__init__(names, ignore_case=True)
     
 def get_default_config():
-    default_config_path = resources.files(__PACKAGE_NAME__) / "default.toml"
+    lang = os.getenv('LANG')[:2] if os.getenv('LANG') else "en"
+    conf_file = lang=="zh" and "default.toml" or "default_en.toml"
+    default_config_path = resources.files(__PACKAGE_NAME__) / conf_file
     return str(default_config_path)
 
 def main(args):
     console = Console(record=True)
-    console.print(f"[bold cyan]🚀 Python use - AIPython ({__version__}) [[green]https://aipy.app[/green]]")
-
+    console.print(f"[bold cyan]🚀 [AIPyApp ({__version__}) on [green]QPython[/green]][/bold cyan] ")
+    console.print(f"[bold cyan]🌐 github.com/qpython-android/aipyapp[/bold cyan] ")
     conf = ConfigManager(get_default_config(), args.config_dir)
     conf.check_config()
     settings = conf.get_config()
 
-    lang = settings.get('lang')
+    lang = settings.get('lang') or or (os.getenv('LANG')[:2] if os.getenv('LANG') else "en")
     if lang: set_lang(lang)
     
     try:
diff --git a/aipyapp/saas.py b/aipyapp/saas.py
index fdc68c7..889a6df 100644
--- a/aipyapp/saas.py
+++ b/aipyapp/saas.py
@@ -1,5 +1,6 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
+import os
 from enum import Enum, auto
 from pathlib import Path
 import importlib.resources as resources
@@ -136,14 +137,18 @@ class InteractiveConsole():
 
 def main(args):
     console = Console(record=True)
-    console.print(f"[bold cyan]🚀 Python use - AIPython ({__version__}) [[green]https://aipy.app[/green]]")
-    
-    default_config_path = resources.files(__PACKAGE_NAME__) / "default.toml"
-    conf = ConfigManager(default_config_path, args.config_dir)
+    console.print(f"[bold cyan]🚀 [AIPyApp ({__version__}) on [[green]QPython[/green]][/bold cyan] ")
+    console.print(f"[bold cyan]🌐 github.com/qpython-android/aipyapp[/bold cyan] ")
+
+    path = args.config if args.config else 'aipy.toml'
+    lang = os.getenv('LANG')[:2] if os.getenv('LANG') else "en"
+    conf_file = lang=="zh" and "default.toml" or "default_en.toml"
+    default_config_path = resources.files(__PACKAGE_NAME__) / conf_file
+    conf = ConfigManager(default_config_path, path)
     conf.check_config()
     settings = conf.get_config()
 
-    lang = settings.get('lang')
+    lang = settings.get('lang') or (os.getenv('LANG')[:2] if os.getenv('LANG') else "en")
     if lang: set_lang(lang)
 
     try:
diff --git a/pyproject.toml b/pyproject.toml
index a4d352f..3fcbc8b 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,5 +1,6 @@
 [project]
 name = "aipyapp"
+version = "0.1.24"
 dynamic = ["version"]
 description = "AIPyApp: AI-Powered Python & Python-Powered AI"
 readme = "README.md"
diff --git a/setup.py b/setup.py
index 76c5cea..4634ca5 100644
--- a/setup.py
+++ b/setup.py
@@ -5,7 +5,7 @@
 from distutils.core import setup
 
 setup(name='aipyapp-qpython',
-      version='0.1.24.1',
+      version='0.1.24.12',
       description='AIPython is a Python command-line interpreter integrated with LLM.',
       author='The AIPYAPP Develpment Team',
       url='https://github.com/qpython-android/aipyapp',
@@ -16,6 +16,7 @@ setup(name='aipyapp-qpython',
 "__main__.py",
 "aipy/*",
 "default.toml",
+"default_en.toml",
 "gui.py",
 "main.py",
 "publish.py",
