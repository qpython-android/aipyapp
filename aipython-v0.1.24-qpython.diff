diff --git a/aipyapp/__main__.py b/aipyapp/__main__.py
index 7af1fd6..cac6783 100644
--- a/aipyapp/__main__.py
+++ b/aipyapp/__main__.py
@@ -1,46 +1,24 @@
 #!/usr/bin/env python
 # coding: utf-8
-
-import argparse
 from pathlib import Path
 
-from .aipy.config import CONFIG_DIR
-
-config_help_message = (
-    f"Specify the configuration directory.\nDefaults to {CONFIG_DIR} if not provided."
-)
-
-def ensure_wxpython():
-    try:
-        import wx
-    except:
-        import sys
-        import subprocess
-
-        cp = subprocess.run([sys.executable, "-m", "pip", "install", 'wxpython'])
-        assert cp.returncode == 0
-
-def mainw():
-    def parse_args():
-        parser = argparse.ArgumentParser(description="Python use - AIPython")
-        parser.add_argument("-c", '--config-dir', type=str,
-                            help=config_help_message) # Use the generated help message
-        parser.add_argument('cmd', nargs='?', default=None, help="Task to execute, e.g. 'Who are you?'")
-        return parser.parse_args()
-    args = parse_args()
-
-    ensure_wxpython()
-    from .wxgui import main as aipy_main
-    aipy_main(args)
+from .aipy.config import SETTINGS_FILES
 
 def main():
+    settings_files_help = "\n".join(map(str, SETTINGS_FILES))
+
+    config_help_message = (
+        f"Toml config file. If not provided, searches in:\n{settings_files_help}"
+    )
 
     def parse_args():
-        parser = argparse.ArgumentParser(description="Python use - AIPython", formatter_class=argparse.RawTextHelpFormatter)
-        parser.add_argument("-c", '--config-dir', type=str,
+        import argparse
+        parser = argparse.ArgumentParser(description="AIPyApp on QPython", formatter_class=argparse.RawTextHelpFormatter)
+        parser.add_argument("-c", '--config', type=str, default="aipy.toml",
                             help=config_help_message) # Use the generated help message
         parser.add_argument('-p', '--python', default=False, action='store_true', help="Python mode")
         parser.add_argument('-g', '--gui', default=False, action='store_true', help="GUI mode")
+
         parser.add_argument('cmd', nargs='?', default=None, help="Task to execute, e.g. 'Who are you?'")
         return parser.parse_args()
 
@@ -49,8 +27,7 @@ def main():
     if args.python:
         from .main import main as aipy_main
     elif args.gui:
-        ensure_wxpython()
-        from .wxgui import main as aipy_main
+        from .gui import main as aipy_main
     else:
         from .saas import main as aipy_main
     aipy_main(args)
diff --git a/aipyapp/aipy/config.py b/aipyapp/aipy/config.py
index 02aaae1..4e41646 100644
--- a/aipyapp/aipy/config.py
+++ b/aipyapp/aipy/config.py
@@ -1,92 +1,17 @@
-import sys
-import time
-import requests # Import requests library
 import os
+import sys
 import re
-import io
-import datetime
-import webbrowser
 from pathlib import Path
 
 from dynaconf import Dynaconf
 from rich import print
-import tomli_w
-import qrcode
-
-
-from .i18n import T
-
-__PACKAGE_NAME__ = "aipyapp"
-
-OLD_SETTINGS_FILES = [
-    Path.home() / '.aipy.toml',
-    Path('aipython.toml').resolve(),
-    Path('.aipy.toml').resolve(),
-    Path('aipy.toml').resolve()
-]
-
-# Coordinator 服务器地址
-COORDINATOR_URL = os.getenv('COORDINATOR_URL', 'https://api.trustoken.ai/api')
-POLL_INTERVAL = 5 # 轮询间隔（秒）
-CONFIG_FILE_NAME = f"{__PACKAGE_NAME__}.toml"
-USER_CONFIG_FILE_NAME = "user_config.toml"
-
-def init_config_dir():
-    """
-    获取平台相关的配置目录，并确保目录存在
-    """
-    if sys.platform == "win32":
-        # Windows 路径
-        app_data = os.environ.get("APPDATA")
-        if app_data:
-            config_dir = Path(app_data) / __PACKAGE_NAME__
-        else:
-            config_dir = Path.home() / "AppData" / "Roaming" / __PACKAGE_NAME__
-    else:
-        # Linux/macOS 路径
-        config_dir = Path.home() / ".config" / __PACKAGE_NAME__
-
-    # 确保目录存在
-    try:
-        config_dir.mkdir(parents=True, exist_ok=True)
-    except PermissionError:
-        print(T('permission_denied_error').format(config_dir))
-        raise
-    except Exception as e:
-        print(T('error_creating_config_dir').format(config_dir, str(e)))
-        raise
-
-    return config_dir
-
-CONFIG_DIR = init_config_dir()
-
-def get_config_file_path(config_dir=None, file_name=CONFIG_FILE_NAME):
-    """
-    获取配置文件的完整路径
-    :return: 配置文件的完整路径
-    """
-    if config_dir:
-        config_dir = Path(config_dir)
-    else:
-        config_dir = CONFIG_DIR
 
-    config_file_path = config_dir / file_name
 
-    # 如果配置文件不存在，则创建一个空文件
-    if not config_file_path.exists():
-        try:
-            config_file_path.touch()
-        except Exception as e:
-            print(T('error_creating_config_dir').format(config_file_path, str(e)))
-            raise
+from .i18n import T, set_lang
 
-    return config_file_path
+SETTINGS_FILES = [Path.home() / '.aipy.toml', Path('aipython.toml').resolve(), Path('.aipy.toml').resolve(), Path('aipy.toml').resolve()]
 
-def lowercase_keys(d):
-    """递归地将字典中的所有键转换为小写"""
-    if not isinstance(d, dict):
-        return d
-    return {k.lower(): lowercase_keys(v) for k, v in d.items()}
+set_lang((os.getenv('LANG')[:2] if os.getenv('LANG') else "en"))
 
 def is_valid_api_key(api_key):
     """
@@ -95,261 +20,86 @@ def is_valid_api_key(api_key):
     :param api_key: 待校验的 API Key 字符串
     :return: 如果格式有效返回 True，否则返回 False
     """
-    pattern = r"^[A-Za-z0-9_-]{8,128}$"
+    pattern = r"^[A-Za-z0-9+/=-]{8,128}$"
     return bool(re.match(pattern, api_key))
 
-def request_binding():
-    """向 Coordinator 请求绑定"""
-    url = f"{COORDINATOR_URL}/request_bind"
-    try:
-        response = requests.post(url, timeout=10)
-        response.raise_for_status()
-
-        data = response.json()
-        approval_url = data['approval_url']
-        request_id = data['request_id']
-        expires_in = data['expires_in']
-
-        print(T('binding_request_sent').format(request_id, approval_url, expires_in))
-        print(T('scan_qr_code'))
-
-        try:
-            qr = qrcode.QRCode(
-                error_correction=qrcode.constants.ERROR_CORRECT_L,
-                border=1
-            )
-            qr.add_data(approval_url)
-            qr.make(fit=True)
-            qr.print_ascii(tty=True)
-            print("\n")
-        except Exception as e:
-            print(T('qr_code_display_failed').format(e))
-
-        return data['request_id']
-
-    except requests.exceptions.RequestException as e:
-        print(T('coordinator_request_error').format(e))
-        return None
-    except Exception as e:
-        print(T('unexpected_request_error').format(e))
-        return None
-
-def poll_status(request_id, save_func=None):
-    """轮询绑定状态"""
-    url = f"{COORDINATOR_URL}/check_status"
-    params = {'request_id': request_id}
-    start_time = time.time()
-    polling_timeout = 310
-
-    print(T('waiting_for_approval'))
-    try:
-        while time.time() - start_time < polling_timeout:
-            try:
-                response = requests.get(url, params=params, timeout=10)
-                response.raise_for_status()
-
-                data = response.json()
-                status = data.get('status')
-                print(T('current_status').format(status))
-
-                if status == 'approved':
-                    if save_func:
-                        save_func(data['secret_token'])
-                    return True
-                elif status == 'expired':
-                    print(T('binding_expired'))
-                    return False
-                elif status == 'pending':
-                    pass
-                else:
-                    print(T('unknown_status').format(status))
-                    return False
-
-            except requests.exceptions.RequestException as e:
-                print(T('coordinator_polling_error').format(e))
-                time.sleep(POLL_INTERVAL)
-            except Exception as e:
-                print(T('unexpected_polling_error').format(e))
-                return False
-
-            time.sleep(POLL_INTERVAL)
-    except KeyboardInterrupt:
-        print(T('polling_cancelled'))
-        return False
-
-    print(T('polling_timeout'))
-    return False
-
-def fetch_token(save_func):
-    """从 Coordinator 获取 Token 并保存"""
-    print(T('start_binding_process'))
-    req_id = request_binding()
-    if req_id:
-        if poll_status(req_id, save_func):
-            print(T('binding_success'))
-        else:
-            print(T('binding_failed'))
-            sys.exit(1)
-    else:
-        print(T('binding_request_failed'))
-        sys.exit(1)
 
 class ConfigManager:
-    def __init__(self, default_config="default.toml",  config_dir=None):
-        self.config_file = get_config_file_path(config_dir)
-        self.user_config_file = get_config_file_path(config_dir, USER_CONFIG_FILE_NAME)
+    def __init__(self, default_config="default.toml", user_config="aipy.toml"):
         self.default_config = default_config
+        self.user_config = user_config
         self.config = self._load_config()
 
-        # old user config, without default config.
-        self._old_user_config = Dynaconf(
-            settings_files=OLD_SETTINGS_FILES,
-            envvar_prefix="AIPY", merge_enabled=True
-        )
-        #print(self.config.to_dict())
-        #print(self._old_user_config.to_dict())
-
     def _load_config(self):
-        config = Dynaconf(
-            settings_files=[self.default_config, self.config_file, self.user_config_file],
-            envvar_prefix="AIPY",
-        )
-        #print(config.to_dict())
+        try:
+            settings_files = [self.default_config] + SETTINGS_FILES[:-1] + [Path(self.user_config).resolve()]
+
+            config = Dynaconf(
+                settings_files=settings_files,
+                envvar_prefix="AIPY", merge_enabled=True
+            )
+        except Exception as e:
+            print(T('error_loading_config').format(e))
+            config = None
         return config
 
     def get_config(self):
         return self.config
 
-    def save_tt_config(self, api_key):
-        config = {
-            'llm': {
-                'trustoken': {
-                    'api_key': api_key,
-                    'type': 'trust',
-                    'base_url': 'https://api.trustoken.ai/v1',
-                    'model': 'auto',
-                    'default': True,
-                    'enable': True
-                }
-            }
-        }
-        header_comments = [
-            f"# Configuration file for {__PACKAGE_NAME__}",
-            "# Auto-generated on " + datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
-            f"# 请勿直接修改此文件，除非您了解具体配置格式，如果自定义配置，请放到{self.user_config_file}",
-            f"# Please do not edit this file directly unless you understand the format. If you want to customize the configuration, please edit {self.user_config_file}",
-            ""
-        ]
-        footer_comments = [
-            "",
-            "# End of configuration file"
-        ]
-
-        with open(self.config_file, "w", encoding="utf-8") as f:
-            # 1. 写入头部注释
-            f.write("\n".join(header_comments) + "\n")
-
-            # 2. 写入 TOML 内容到临时内存文件
-
-            temp_buffer = io.BytesIO()
-            tomli_w.dump(config, temp_buffer)
-            toml_content = temp_buffer.getvalue().decode('utf-8')
-
-            # 3. 写入 TOML 内容
-            f.write(toml_content)
-
-            # 4. 写入尾部注释
-            f.write("\n".join(footer_comments))
-
-        return config
-
     def check_config(self):
+        if not self.config:
+            print(T('config_file_error'))
+            return
 
+        self.check_llm()
+
+    def check_llm(self):
         if not self.config:
             print(T('config_not_loaded'))
             return
-        tt = self.config.get('llm', {}).get('trustoken', {})
-        if tt and tt.get('api_key') and tt.get('type') == 'trust':
-            # valid tt config
-            #print("trustoken config found")
-            return
-        elif self._old_user_config.to_dict():
-            # no tt config, try to migrate from old config
-            # remove this later.
-            self._migrate_old_config(self._old_user_config)
-        else:
-            # try to fetch config from web.
-            fetch_token(self.save_tt_config)
-        
-        # reload config
-        self.config = self._load_config()
 
-    def _migrate_old_config(self, old_config):
-        """
-        从old_config中提取符合特定条件的API keys，并从原始配置中删除
-        
-        返回: 提取的API keys字典，格式为 {配置名称: API key}
-        """
-        if not old_config:
-            return {}
+        llm = self.config.get("llm")
+        if not llm:
+            print(T('llm_config_not_found'))
 
-        tt_keys = []
+        llms = {}
+        for name, config in self.config.get('llm', {}).items():
+            if config.get("enable", True):
+                llms[name] = config
 
-        # 处理顶级配置
-        llm = old_config.get('llm', {})
-        for section_name, section_data in list(llm.items()):
-            # 跳过非字典类型的配置
-            if not isinstance(section_data, dict):
-                continue
+        if not llms:
+            self._init_llm()
+
+    def _init_llm(self):
+        print(T('pgpttoken_register_instruction').format(self.user_config))
 
-            # 检查顶级配置
-            if self._is_tt_config(section_name, section_data):
-                api_key = section_data.get('api_key', '')
-                if api_key:
-                    tt_keys.append(api_key)
-                # 从原配置中删除
-                llm.pop(section_name)
+        while True:
+            user_token = input(T('prompt_token_input')).strip()
+            if user_token.lower() == "exit":
+                print(T('exit_token_prompt'))
+                sys.exit(0)
+            if not user_token:
+                print(T('no_token_detected'))
+                continue
+            if not is_valid_api_key(user_token):
+                print(T('invalid_token'))
+                continue
 
-        #print("keys found:", tt_keys)
+            self.save_trustoken(user_token)
 
-        if tt_keys:
-            # 保存第一个找到的API key
-            self.save_tt_config(tt_keys[0])
+            self.config = self._load_config()
+            break
 
-        #print(old_config.to_dict())
-        # 将 old_config 转换为 dict
-        config_dict = lowercase_keys(old_config.to_dict())
+    def save_trustoken(self, token):
+        config_file = self.user_config
         try:
-            with open(self.user_config_file, "wb") as f:
-                tomli_w.dump(config_dict, f)
-                print(T('migrate_config').format(self.user_config_file))
+            with open(config_file, "a") as f:
+                f.write("\n[llm.pgpt]\n")
+                f.write(f'api_key = "{token}"\n')
+                f.write('base_url = "https://openai.pgpt.cloud/v1/"\n')
+                f.write('model = "auto"\n')
+                f.write("default = true\n")
+                f.write("enable = true\n")
+            print(T('token_saved').format(config_file))
         except Exception as e:
-            print(T('error_saving_config').format(self.user_config_file, str(e)))
-        return
-
-    def _is_tt_config(self, name, config):
-        """
-        判断配置是否符合特定条件
-        
-        参数:
-            name: 配置名称
-            config: 配置内容字典
-        
-        返回: 如果符合条件返回True
-        """
-        # 条件1: 配置名称包含目标关键字
-        if any(keyword in name.lower() for keyword in ['trustoken', 'trust']):
-            return True
-
-        # 条件2: base_url包含目标域名
-        if isinstance(config, dict) and 'base_url' in config:
-            base_url = config['base_url'].lower()
-            if 'trustoken.ai' in base_url:
-                return True
-
-        # 条件3: 其他特定标记
-        # type == trust, 且没有base_url.
-        if isinstance(config, dict) and config.get('type') == 'trust' and not config.get('base_url'):
-            return True
-        
-        return False
\ No newline at end of file
+            print(T('token_save_error').format(e))
diff --git a/aipyapp/aipy/i18n.py b/aipyapp/aipy/i18n.py
index afdf834..f4ac80a 100644
--- a/aipyapp/aipy/i18n.py
+++ b/aipyapp/aipy/i18n.py
@@ -56,6 +56,14 @@ MESSAGES = {
             "点击“复制”按钮，复制令牌到剪贴板。在下面进行粘贴。\n"
             "另外，也可以选择退出，然后手动编辑配置文件 {}，配置自己已有的其他大模型令牌"
         ),
+        'pgpttoken_register_instruction': (
+            "当前环境缺少配置文件，需要注册PGPT账号获取试用Token。\n"
+            "请按以下步骤操作：\n"
+            "1. 访问 https://user.pgpt.cloud/ 完成账号注册\n"
+            "2. 登录后创建App（选择deepseek）。操作详见文档 https://docs.pgpt.cloud/\n"
+            "3. 获取API Key并复制到剪贴板，然后在此粘贴\n"
+            "您也可以选择退出，然后手动编辑配置文件 {} 来配置已有的其他大模型Token"
+        ),
         'prompt_token_input': "请粘贴令牌并按 Enter 键 (输入 'exit' 退出): ",
         'exit_token_prompt': "退出令牌输入流程。",
         'no_token_detected': "未检测到令牌输入。",
@@ -136,6 +144,14 @@ MESSAGES = {
             "Click the 'copy' button to copy your token to the clipboard and paste it here.\n"
             "Alternatively, you can exit now, and manually edit the configuration file {} to configure your existing LLM token."
         ),
+        'pgpttoken_register_instruction': (
+            "The current environment is missing configuration files. You need to register a PGPT account to get trial tokens.\n"
+            "Please follow these steps:\n"
+            "1. Visit https://user.pgpt.cloud/ to complete account registration\n"
+            "2. After logging in, create an App (please select deepseek). See documentation: https://docs.pgpt.cloud/\n"
+            "3. Get your API Key, copy it to clipboard, then paste it here\n"
+            "Alternatively, you can exit and manually edit the configuration file {} to set up tokens for other existing LLM models"
+        ),
         'prompt_token_input': "Please paste the token and press Enter (type 'exit' to quit): ",
         'exit_token_prompt': "Exiting token input process.",
         'no_token_detected': "No token detected.",
diff --git a/aipyapp/aipy/llm.py b/aipyapp/aipy/llm.py
index 8cf3bb4..c25a03f 100644
--- a/aipyapp/aipy/llm.py
+++ b/aipyapp/aipy/llm.py
@@ -59,7 +59,7 @@ class LiveManager:
         self.live = Live(console=console, auto_refresh=False, vertical_overflow='visible', transient=True)
         self.live.__enter__()
         status = self.console.status(f"[dim white]{self.name} {T('thinking')}...", spinner='runner')
-        response_panel = Panel(status, title=self.title, border_style="blue")
+        response_panel = Panel(status, title=f"[blue] 🤖️ {self.title} ")
         self.live.update(response_panel, refresh=True)
         return self
 
@@ -76,10 +76,10 @@ class LiveManager:
         full_response = self.lr.content
         try:
             md = Markdown(full_response)
-            response_panel = Panel(md, title=self.title, border_style="green")
+            response_panel = Panel(md, title=f"[green] 🤖️ {self.title} ")
         except Exception:
             text = Text(full_response)
-            response_panel = Panel(text, title=self.title, border_style="yellow")
+            response_panel = Panel(text, title=f"[yellow] 🤖️ {self.title} ")
         self.live.update(response_panel, refresh=True)
         self.response_panel = response_panel
         self.full_response = full_response
@@ -427,13 +427,18 @@ class AzureOpenAIClient(OpenAIBaseClient):
     def _get_client(self):
         from openai import AzureOpenAI
         return AzureOpenAI(azure_endpoint=self._end_point, api_key=self._api_key, api_version="2024-02-01")
-            
+
+class PGPTAIClient(OpenAIBaseClient):
+    BASE_URL = "https://openai.pgpt.cloud/v1/"
+    MODEL = "auto"
+
 class LLM(object):
     CLIENTS = {
         "openai": OpenAIClient,
         "ollama": OllamaClient,
         "claude": ClaudeClient,
         "gemini": GeminiClient,
+        "pgptai": PGPTAIClient,
         "deepseek": DeepSeekClient,
         'grok': GrokClient,
         'trust': TrustClient,
diff --git a/aipyapp/aipy/prompt.py b/aipyapp/aipy/prompt.py
index 3db0629..41cffb5 100644
--- a/aipyapp/aipy/prompt.py
+++ b/aipyapp/aipy/prompt.py
@@ -1,13 +1,30 @@
 #!/usr/bin/env python
 # coding: utf-8
 
+def get_first_two_lines(docstring):
+    if docstring:
+        lines = docstring.split('\n')
+        # 检查前两行是否都有内容
+        if len(lines) >= 2 and lines[0].strip() and lines[1].strip():
+            return ': '.join(lines[:2])
+        # 如果只有一行且有内容，返回第一行
+        elif len(lines) == 1 and lines[0].strip():
+            return lines[0].strip()
+    # 如果没有内容，返回空字符串
+    return ""
+
 SYSTEM_PROMPT = """
-# 代码块格式规范
 
-回复消息使用标准 Markdown 格式，请在回答中使用以下格式标记所有代码块：
+在和用户对话时，需要应用以下规范
+When talking to users, the following guidelines should be applied:
+- <代码回复格式规范> 和 <代码执行结果反馈>
+
+<代码回复格式规范>
+## 回复格式
+回复消息使用标准 Markdown 格式，请在回答中务必使用以下格式标记所有代码块：
 
 ````lang name
-代码内容
+<代码内容>
 ````
 
 其中：
@@ -17,6 +34,7 @@ SYSTEM_PROMPT = """
   - 需要执行的Python代码块，名称必须且只能为"main"
   - 每次回答中最多只能包含一个名为"main"的可执行代码块
   - 所有不需要执行的Python代码块，必须使用非"main"的其他名称标识
+  - 代码外部必须使用四个反引号
 
 示例：
 ````python main
@@ -36,25 +54,71 @@ def greet(name):
 }
 ````
 
-# Python 运行环境描述
+## 程序头部
+每个程序头部自动加入以下代码：
+````python
+# -*- coding: utf8; -*-
+# Generated by AIPyApp@QPython
+import qpy
+````
+
+## Python 代码规则
+- 确保代码在上述 Python 运行环境中可以无需修改直接执行
+- 如果需要安装额外库，先调用 runtime 对象的 install_packages 方法申请安装
+- 实现适当的错误处理，包括但不限于：
+  * 文件操作的异常处理
+  * 网络请求的超时和连接错误处理
+  * 数据处理过程中的类型错误和值错误处理
+- 确保代码安全，不执行任何有害操作
+- 代码里，正常信息必需输出到 stdout，错误信息必需输出到 stderr。
+- 不允许执行可能导致 Python 解释器退出的指令，如 exit/quit 等函数，请确保代码中不包含这类操作。
+- 函数内部使用运行环境提供的全局变量必须先用 global 声明。
+</代码回复格式规范>
+
+<代码执行结果反馈>
+每执行完一段Python代码，我都会立刻通过一个 JSON 对象反馈执行结果给你，对象包括以下属性：
+- `stdout`: 标准输出内容
+- `stderr`: 标准错误输出
+- `__result__`: __result__ 变量的值
+- `errstr`: 异常信息
+- `traceback`: 异常堆栈信息
+
+注意：
+- 如果某个属性为空，它不会出现在反馈中。
+- 如果代码没有任何输出，用户会反馈一对空的大括号 {{}}。
+
+生成Python代码的时候，你可以有意使用 stdout / stderr 以及前述 __result__ 变量来记录执行情况。
+但避免在 stdout 和 vars 中保存相同的内容，这样会导致反馈内容重复且太长。
+
+收到反馈后，结合代码和反馈数据，做出下一步的决策。
+</代码执行结果反馈>
+
 
+在设计、开发 QPython 程序时，有以下规范需要考虑：
+- <Python 运行基础环境和第三方库> 指明了 Python 所运行的环境和可以使用的库
+- <QPython androidhelper 模块详情> 介绍了 QPython 的 SL4A 模块 androidhelper 的详细用法和使用流程
+- <QPython fullscreenwapper 模块详情> 介绍了 QPython 的 GUI 模块 fullscreenwapper 的详细用法和使用流程
+- <QPython WEB 应用> 介绍了 QPython 的 WEB 应用开发的规范和流程
+- <PGPT API 信息> 介绍了 PGPT API 服务的详细用法和使用流程
+
+<Python 运行基础环境和第三方库>
 ## 可用模块
 - Python 自带的标准库模块。
-- 预装的第三方模块有：`requests`、`numpy`、`pandas`、`matplotlib`、`seaborn`、`bs4`、`googleapiclient`。
+- QPython 自带的标准模块：`qpy`, `androidhelper`。
+- 预装的第三方模块有：`requests`、`numpy`、`pandas`、`matplotlib`、`plotpy`、`seaborn`、`bs4`、`google-api-python-client`, `bottle`。
 - 在必要情况下，可以通过下述 runtime 对象的 install_packages 方法申请安装额外模块。
 
-在使用 matplotlib 时，需要根据系统类型选择和设置合适的中文字体，否则图片里中文会乱码导致无法完成客户任务。
+## Matplotlib 注意事项
+在使用 matplotlib 时，需要根据系统类型选择和设置合适的中文字体，否则图片里中文会乱码导致无法完成用户任务。
 示例代码如下：
-```python
+````python
 import platform
 
 system = platform.system().lower()
 font_options = {
-    'windows': ['Microsoft YaHei', 'SimHei'],
-    'darwin': ['Kai', 'Hei'],
-    'linux': ['Noto Sans CJK SC', 'WenQuanYi Micro Hei', 'Source Han Sans SC']
+    'linux': ['Roboto', 'Noto Sans CJK SC', 'Droid Sans', 'Open Sans', 'Lato', 'Montserrat', 'WenQuanYi Micro Hei', 'Source Han Sans SC']
 }
-```
+````
 
 ## 全局 runtime 对象
 runtime 对象提供一些协助代码完成任务的方法。
@@ -65,10 +129,10 @@ runtime 对象提供一些协助代码完成任务的方法。
 - 返回值：True 表示成功，False 表示失败
 
 示例如下：
-```python
+````python
 if runtime.install_packages(['datasets']):
     import datasets
-```
+````
 
 ### runtime.getenv 方法
 - 功能: 获取代码运行需要的环境变量，如 API-KEY 等。
@@ -77,7 +141,7 @@ if runtime.install_packages(['datasets']):
 - 返回值：环境变量值，返回 None 或空字符串表示未找到。
 
 示例如下：
-```python
+````python
 env_name = '环境变量名称'
 env_value = runtime.getenv(env_name, "No env", desc='访问API服务需要')
 if not env_value:
@@ -85,15 +149,15 @@ if not env_value:
 else:
     print(f"{env_name} is available")
     __result__ = {'env_available': True}
-```
+````
 
 ### runtime.display 方法
-如果 TERM 环境变量为 `xterm-256color` 或者 LC_TERMINAL 环境变量为 `iTerm2`，你可以用使用这个方法在终端上显示图片。
+如果 TERM 环境变量为 `xterm-256color` 或 `xterm` 或 `screen-256color` 或者 LC_TERMINAL 环境变量为 `iTerm2`，你可以用使用这个方法在终端上显示图片。
 示例：
-```python
+````python
 runtime.display(path="path/to/image.png")
 runtime.display(url="https://www.example.com/image.png")
-```
+````
 
 ## 全局变量 __session__
 - 类型：字典。
@@ -101,9 +165,9 @@ runtime.display(url="https://www.example.com/image.png")
 - 用途：可以在多次会话间共享数据。
 - 注意: 如果在函数内部使用，必须在函数开头先声明该变量为 global
 - 使用示例：
-```python
+````python
 __session__['step1_result'] = calculated_value
-```
+````
 
 ## 全局变量 __history__
 - 类型：字典。
@@ -111,75 +175,517 @@ __session__['step1_result'] = calculated_value
 - 用途：保存代码执行历史。即，每次执行的代码和执行结果
 - 注意: 如果在函数内部使用，必须在函数开头先声明该变量为 global
 - 使用示例：
-```python
+````python
 # 获取上一次执行的 Python 代码源码
 last_python_code = __history__[-1]['code']
-```
+````
 
 ## 全局变量 __code_blocks__
 - 类型: 字典。
 - 用途: 获取本次回复消息里命名代码块的内容，例如：
-```python
+````python
 current_python_code = __code_blocks__['main']
-```
+````
 
 如果需要保存成功执行的代码，可以在判断代码成功执行后，通过 __code_blocks__['main'] 获取自身的内容，无需嵌入代码块。
-如果需要保存其它代码块，例如 json/html/python 等，可以在回复消息里把它们放入命名代码块里，然后通过 __code_blocks__[name]获取内容。
+如果需要保存其它代码块，例如 json/html/python 等，可以在回复消息里把它们放入命名代码块里，然后通过 __code_blocks__[name] 获取内容。
 
 ## 全局变量 __result__
 - 类型: 字典。
 - 有效期：仅在本次执行的代码里有效。
 - 用途: 用于记录和返回代码执行情况。
-- 说明: 本段代码执行结束后，客户会把 __result__ 变量反馈给你判断执行情况
+- 说明: 本段代码执行结束后，用户会把 __result__ 变量反馈给你判断执行情况
 - 注意: 如果在函数内部使用，必须在函数开头先声明该变量为 global
 - 使用示例(函数外部使用)：
-```python
+````python
 __result__ = {"status": "success", "message": "Task completed successfully"}
-```
+````
 函数内部使用示例：
-```python
+````python
 def main():
     global __result__
     __result__ = {"status": "error", "message": "An error occurred"}
-```
-例如，如果需要分析客户端的文件，你可以生成代码读取文件内容放入 __result__变量返回后分析。
+````
+例如，如果需要分析用户端的文件，你可以生成代码读取文件内容放入 __result__ 变量返回后分析。
 
-# 生成Python代码规则
-- 确保代码在上述 Python 运行环境中可以无需修改直接执行
-- 如果需要安装额外库，先调用 runtime 对象的 install_packages 方法申请安装
-- 实现适当的错误处理，包括但不限于：
-  * 文件操作的异常处理
-  * 网络请求的超时和连接错误处理
-  * 数据处理过程中的类型错误和值错误处理
-- 确保代码安全，不执行任何有害操作
-- 代码里，正常信息必需输出到 stdout，错误信息必需输出到 stderr。
-- 不允许执行可能导致 Python 解释器退出的指令，如 exit/quit 等函数，请确保代码中不包含这类操作。
-- 函数内部使用运行环境提供的全局变量必须先用 global 声明。
+## 第三方 API 服务
+有时程序会需要调用第三方 API ，调用这些 API 可能会需要由用户提供 API_KEY，URL，用途和使用方法等信息。
+这些 API 信息里描述的环境变量必须用 runtime.getenv 方法获取，绝对不能使用 os.getenv 方法。
 
-# 代码执行结果反馈
-每执行完一段Python代码，我都会立刻通过一个JSON对象反馈执行结果给你，对象包括以下属性：
-- `stdout`: 标准输出内容
-- `stderr`: 标准错误输出
-- `__result__`: __result__ 变量的值
-- `errstr`: 异常信息
-- `traceback`: 异常堆栈信息
 
-注意：
-- 如果某个属性为空，它不会出现在反馈中。
-- 如果代码没有任何输出，客户会反馈一对空的大括号 {{}}。
+## QPython qpy 模块 介绍
+qpy 是 QPython 一个内置的模块，能用于定位 QPython 中的资源存放路径：
+- QPY缓存目录，存储在 qpy.tmp 这个变量里
+- QPY脚本目录，也叫QPY程序目录，用于存放QPY脚本，存储在 qpy.scripts 这个变量里
+- QPY项目根目录，也叫QPY应用根目录，用于存放QPY项目，存储在 qpy.projects 这个变量里
+- QPY笔记目录，也叫QPY Notebook目录，用于存放QPY笔记，存储在 qpy.notebooks 这个变量里
 
-生成Python代码的时候，你可以有意使用stdout/stderr以及前述__result__变量来记录执行情况。
-但避免在 stdout 和 vars 中保存相同的内容，这样会导致反馈内容重复且太长。
+当需要使用这些目录时，需要先引入qpy，如：
+````python
+import os
+import qpy
+script_file = os.path.join(qpy.scripts,  "test_script.py") # 如果当前开发的脚本文件名为test_script.py，能通过这种方法得到QPY脚本全路径
+project_dir = os.path.join(qpy.projects,  "todoApp") # 如果当前开发的目录名为todoApp，能通过这种方法得到QPY项目目录全路径
+notebook_file = os.path.join(qpy.notebooks,  "hello.ipynb") # 如果当前在开发的笔记名为hello.ipynb，能通过这种方法得到QPY笔记全路径
+````
 
-收到反馈后，结合代码和反馈数据，做出下一步的决策。
+## QPython 的 QSL4A 模块 androidlhelper 介绍
+Android 脚本层（简称 SL4A，之前称为 Android 脚本环境或 ASE）是一个库，允许直接在 Android 设备上创建和运行用各种脚本语言编写的脚本。QPython 继承和扩展了 SL4A 项目为 QSL4A，并将其集成为一个名为 androidhelper 的内置库。在提到 QPY SL4A、QPython SL4A、QSL4A 或 QPY Android 模块时，我们指的是通过使用 androidhelper 模块接口进行开发。
+需要注意，大部分的 androidhelper 接口在调用时，如果没有返回输出到控制台，也表示成功
+
+## QPython 的 GUI 模块 fullscreenwapper 介绍
+QPython 的 fullscreenwapper 是一个基于 QSL4A FullScreen UI API 开发全屏应用的 GUI 框架，允许使用 XML 布局创建类似 Android Java 应用的界面，并支持 View 事件响应。该框架使 QSL4A 的 FullScreenUI API 使用体验接近标准 GUI 框架。QPY GUI 或 QPython GUI 应用特指基于此框架开发的程序。
+需要注意，大部分的 fullscreenwapper 接口在调用时，如果没有返回输出到控制台，也表示成功
+
+## QPython WEB 应用
+QPython WEB 应用，也可以叫做 QPython WebApp 或 QPY WEBAPP，是一种方便易开发的基于 QPython 的手机应用。 QPython 内置有 WEBVIEW 组件，并提供了内置接入规范，开发者只需要按照接入规范开发好一个 WEB 应用，即可通过 QPython 的内置 WEBVIEW 打开浏览，成为 QPython 的 WEB 应用。
+
+## PGPT API 服务介绍
+PGPT 是一个生成式 AI 云服务，旨在为开发者提供一站式集成多个 AIGC 服务商 API 的服务。能帮用户处理文本翻译、文字总结或生成、图像生成在内的多种服务，对于不同的需求，它提供了多个接口可供调用，只需一个账号，即可开通多种服务。
+</Python 运行基础环境和第三方库>
+
+<QPython fullscreenwapper 模块详情>
+作为 QPython GUI 的框架, fullscreenwapper 包含以下内容：
+
+## 核心特性
+- FullScreenWrapper2App 类：管理事件循环和布局栈，实现父子布局平滑过渡
+- 预置事件处理器：支持点击、列表项点击、按键等标准视图事件
+- 统一事件管理：通过相同机制处理设备传感器和自定义事件
+- 对象化属性访问：直接操作布局视图属性（如 MainLayout.views.txt_label.background）
+
+## 如何使用
+你可以通过以下步骤来使用 fullscreenwapper 创建 QPY GUI 程序：
+
+- 1. 导入 fullscreenwrapper 并定义你的布局类
+QPython 已将 fullscreenwrapper 集成为内置库。首先，你需要导入 fullscreenwrapper 中的所有内容，并从 Layout 类继承一个用于自定义布局的类，然后使用 super 关键字，传入 XML 布局（字符串）和屏幕标题（字符串）参数，调用 Layout 的 init 函数。
+
+````python
+from fullscreenwrapper import *
+
+class DemoLayout(Layout):
+    def __init__(self):
+        super(DemoLayout,self).__init__(xmldata,"FullScreenWrapper Demo")
+````
+
+- 2. 定义 on_show() 和 on_close() 函数
+on_show() 函数非常重要，因为只有在框架调用 on_show() 之后，您的视图才能通过 FullScreenWrapper 框架访问。您可以在此处初始化/设置视图的值并设置事件处理程序。如果您使用的是父子布局，则当子布局关闭且父布局重新打开时，也会调用 on_show() 函数。
+可以通过 Layout.views.view_id.property 访问视图及其属性。在下面的示例中，我们设置了背景颜色——大多数简单的属性都应该可以正常工作。
+布局和各个视图都可以关联事件。通常，您会将 click_EventHandler 和 itemclick_EventHandlers（用于 ListView）与视图一起使用。这些事件处理程序的初始化函数将视图本身以及事件发生时要调用的事件处理程序函数引用作为参数。
+通常，您会将 key_EventHandler 与布局本身关联。 key_EventHandler 的初始化采用 key_match_id（默认为“4”，即返回键）、视图（默认为无）和事件处理程序函数引用作为参数。
+
+````python
+    def on_show(self):
+        self.add_event(key_EventHandler(handler_function=self.close_app))
+        self.views.but_change.add_event(click_EventHandler(self.views.but_change,
+self.change_color))
+        self.views.but_exit.add_event(click_EventHandler(self.views.but_exit, self.close_app))
+        self.views.txt_colorbox.background="#ffffffff"
+````
+
+对于陀螺仪等传感器事件，您可以直接使用 EventHandler 类 - 只需设置即可。
+您可以访问视图的属性 Layout.views.view_id.property
+
+````python
+    def on_show(self):
+        self.add_event(key_EventHandler(handler_function=self.close_app))
+        self.views.but_change.add_event(click_EventHandler(self.views.but_change,
+self.change_color))
+        self.views.but_exit.add_event(click_EventHandler(self.views.but_exit, self.close_app))
+        self.views.txt_colorbox.background="#ffffffff"
+````
+
+on_close() 主要用于在布局消失前根据需要保存状态。您可以将 pass 作为唯一的语句。
+
+````python
+    def on_close(self):
+        pass
+
+````
+
+只有在框架调用布局的 on_show() 后，视图才可访问，这是 FullScreenUI 的工作方式所致。您需要先显示布局，然后才能访问其视图。FullScreenWrapper 使用 Android.fullGetProperty() 查找哪些视图包含“id”且可供访问，然后创建并填充每个布局的视图集合中的视图对象。这些视图对象允许您将事件与其关联，并允许您使用 setattr() 和 getattr() 通过 SL4A 反射访问属性。布局通过添加到视图集合中的特殊视图来处理其事件。
+
+- 3. 创建事件处理函数和其他函数
+事件处理函数定义签名应如下所示：
+
+````python
+def event_handler_function(self,view,event): pass
+````
+
+每个事件处理程序都会传递一个与该事件关联的视图的引用（可以为 None）以及从 Android.eventPoll().result0 获取的 SL4A 事件数据。在下面的示例中，每次按下屏幕上的按钮时，文本框的背景都会变为随机颜色。
+
+````python
+    def close_app(self,view,event):
+        FullScreenWrapper2App.exit_FullScreenWrapper2App()
+
+    def change_color(self,view, event):
+        colorvalue =
+"#ff"+self.get_rand_hex_byte()+self.get_rand_hex_byte()+self.get_rand_hex_byte()
+        self.views.txt_colorbox.background=colorvalue
+
+    def get_rand_hex_byte(self):
+        j = random.randint(0,255)
+        hexrep = hex(j)[2:]
+        if(len(hexrep)==1):
+            hexrep = '0'+hexrep
+        return hexrep
+````
 
-# 一些 API 信息
-下面是客户提供的一些 API 信息，可能有 API_KEY，URL，用途和使用方法等信息。
-这些可能对特定任务有用途，你可以根据任务选择性使用。
+- 4. 初始化全屏包装器 (FullScreenWrapper)、显示布局并执行事件循环
+设置好布局类后，在主函数中，首先使用 Android.Android() 初始化框架。然后使用 FullScreenWrapper2App.show_layout() 显示布局并启动事件循环 (EventLoop)。
 
-注意：这些 API 信息里描述的环境变量必须用 runtime.getenv 方法获取，绝对不能使用 os.getenv 方法。
+````python
+if __name__ == '__main__':
+    import androidhelper
+    droid = androidhelper.Android()
+    random.seed()
+    FullScreenWrapper2App.initialize(droid)
+    FullScreenWrapper2App.show_layout(DemoLayout())
+    FullScreenWrapper2App.eventloop()
 
+````
+
+- 5. 整合
+对于简单的 XML 布局，您只需在模块中将布局定义在字符串变量中即可。但是，随着应用变得越来越复杂，您可能需要从 SD 卡文件甚至互联网加载。
+
+````python
+import androidhelper, random
+from fullscreenwrapper import *
+
+class DemoLayout(Layout):
+    def __init__(self):
+        super(DemoLayout,self).__init__(xmldata,"FullScreenWrapper Demo")
+
+    def on_show(self):
+        self.add_event(key_EventHandler(handler_function=self.close_app))
+        self.views.but_change.add_event(click_EventHandler(self.views.but_change,
+self.change_color))
+        self.views.but_exit.add_event(click_EventHandler(self.views.but_exit, self.close_app))
+        self.views.txt_colorbox.background="#ffffffff"
+
+    def on_close(self):
+        pass
+
+    def close_app(self,view,event):
+        FullScreenWrapper2App.exit_FullScreenWrapper2App()
+
+    def change_color(self,view, event):
+        colorvalue =
+"#ff"+self.get_rand_hex_byte()+self.get_rand_hex_byte()+self.get_rand_hex_byte()
+        self.views.txt_colorbox.background=colorvalue
+
+    def get_rand_hex_byte(self):
+        j = random.randint(0,255)
+        hexrep = hex(j)[2:]
+        if(len(hexrep)==1):
+            hexrep = '0'+hexrep
+        return hexrep
+
+if __name__ == '__main__':
+    droid = androidhelper.Android()
+    random.seed()
+    FullScreenWrapper2App.initialize(droid)
+    FullScreenWrapper2App.show_layout(DemoLayout())
+    FullScreenWrapper2App.eventloop()
+````
+
+## 注意事项
+- 更新ListView的内容需要调用set_listitems方法
+</QPython fullscreenwapper 模块详情>
+
+<PGPT API 服务>
+PGPT API 云服务，旨在为开发者提供了一个集成多个 AIGC 服务商 API 的一站式的服务，能为开发者提供多种多样包括不限于翻译、AI画图、内容总结、内容概括等在内的 API 服务。目前提供的 API 服务如下：
+
+## 翻译接口 Translate
+Translate AI借助机器翻译的最新创新技术，可以即时或批量翻译100多种语言的文本，支持广泛的用例。
+
+使用例子
+> translate请求示范
+
+````python
+import request
+
+HOST = 'https://ai.pgpt.cloud'
+API_KEY = '<YOUR_API_KEY>'
+
+header = {
+    "Content-Type": "application/json",
+    "Authorization": f"Bearer {API_KEY}",
+}
+payload = {
+    "to_lang": ['zh-Hans', 'pt', 'en'],
+    "text": "我爱中国"
+}
+
+res = requests.post(
+    url=f"{HOST}/v1/translate/",
+    headers=headers,
+    json=payload,
+)
+print(res.json())
+
+````
+
+> 返回示例
+
+````json
+{ "translations": [
+        [
+            {   "text": "我爱中国",
+                "to": "zh-Hans" },
+            {   "text": "Eu amo a China",
+                "to": "pt" },
+            {   "text": "I love China",
+                "to": "en" }
+        ]
+    ]
+}
+````
+
+参数
+- Endpoint: https://ai.pgpt.cloud/v1/translate/
+- Method: POST
+- Request Body:
+  - 参数 text `string | array` required:  要翻译的文本内容
+  - 参数 to_lang `array` required:  文本要翻译成哪种语言
+
+- Response:
+  - 参数 translations `array`: 根据请求参数 `to_lang` 中指定的翻译语言返回所有翻译完成的文本列表，包含翻译完成的文本内容及语言
+    {   text | 翻译完成的文本
+        to | 翻译语言 }
+</PGPT API 服务>
+
+
+<QPython WEB 应用>
+## 可以用什么框架来开发
+推荐使用Bottle 框架进行，这是 QPython 内置的 WEB 开发框架，同时也支持 Flask / Django 等框架
+
+## 如何开发一个 QPython WEB 应用
+- 1. 首先需要在你的 QPython 程序头部加入以下定义：
+````python
+#qpy:webapp:<应用标题>
+#qpy://<webapp-address>:<webapp-port>/<webapp-path>
+#-*- coding: utf8; -*-
+````
+其中:
+  - webapp-address: 表示 WEB 程序运行时绑定的地址
+  - webapp-port: 表示 WEB 程序运行时绑定的端口
+  - webapp-path: 表示 WEB 程序运行的入口路径
+
+````python
+#qpy:webapp:Hello QPython
+#qpy://127.0.0.1:8080/
+#-*- coding: utf8; -*-
+````
+
+- 2. 使用WEB开发框架，比如bottle / flask / django来开发一个 WEB 程序，确保程序运行时的地址，端口，还有默认的入口路径分别为<webapp-address>, <webapp-port>, <webapp-path>
+
+比如：
+````python
+import os
+from bottle import Bottle, ServerAdapter
+from bottle import run, debug, route, error, static_file, template
+
+### QPYTHON WEB SERVER ###
+class MyWSGIRefServer(ServerAdapter):
+    server = None
+
+    def run(self, handler):
+        from wsgiref.simple_server import make_server, WSGIRequestHandler
+        if self.quiet:
+            class QuietHandler(WSGIRequestHandler):
+                def log_request(*args, **kw): pass
+            self.options['handler_class'] = QuietHandler
+        self.server = make_server(self.host, self.port, handler, **self.options)
+        self.server.serve_forever()
+
+    def stop(self):
+        #sys.stderr.close()
+        import threading
+        threading.Thread(target=self.server.shutdown).start()
+        #self.server.shutdown()
+        self.server.server_close() #<--- alternative but causes bad fd exception
+        print("# qpyhttpd stop")
+
+
+@route('/assets/<filepath:path>')
+def server_static(filepath):
+    return static_file(filepath, root=os.path.dirname(os.path.abspath(__file__)))
+
+### WEBAPP ROUTERS ###
+@route('/')
+def home():
+    name='QPython'
+    cont=f'''<h1>Hello {name} !</h1>'''
+    return template(cont)
+
+### WEBAPP ROUTERS ###
+app = Bottle()
+app.route('/', method='GET')(home)
+app.route('/assets/<filepath:path>', method='GET')(server_static)
+
+try:
+    server = MyWSGIRefServer(host="127.0.0.1", port="8080") # 此处绑定了127.0.0.1:8080 地址和端口正好是头部定义的地址和端口
+    app.run(server=server,reloader=False)
+except (Exception) as ex:
+    print("Exception: %s" % repr(ex))
+````
+
+
+- 3. 实现一些必要的业务逻辑支持 QPython WEB 来响应一些特殊操作
+  - 为了能正常响应关闭 QPython WEB 应用，你需要实现支持 GET 操作的 http://<webapp-address>:<webapp-port>/__exit ，确保里面有退出 QPython WEB 应用时的业务逻辑
+  - 为了能正常响应检测存活 QPython WEB 应用，你需要实现支持 GET 操作的 http://<webapp-address>:<webapp-port>/__ping , 你的程序正常时返回200的成功码
+
+比如：
+````python
+...
+
+### BUILT-IN ROUTERS ###
+@route('/__exit', method=['GET','HEAD'])
+def __exit():
+    global server
+    server.stop()
+
+@route('/__ping')
+def __ping():
+    return "ok"
+
+...
+
+app.route('/__exit', method=['GET','HEAD'])(__exit)
+app.route('/__ping', method=['GET','HEAD'])(__ping)
+app.route('/assets/<filepath:path>', method='GET')(server_static)
+
+...
+
+````
+
+- 4. 其他自定义业务
+
+最后整合到一起
+````python main
+#qpy:webapp:Hello QPython
+#qpy://127.0.0.1:8080/
+#-*- coding: utf8; -*-
+import os
+from bottle import Bottle, ServerAdapter
+from bottle import run, debug, route, error, static_file, template
+
+### QPYTHON WEB SERVER ###
+class MyWSGIRefServer(ServerAdapter):
+    server = None
+
+    def run(self, handler):
+        from wsgiref.simple_server import make_server, WSGIRequestHandler
+        if self.quiet:
+            class QuietHandler(WSGIRequestHandler):
+                def log_request(*args, **kw): pass
+            self.options['handler_class'] = QuietHandler
+        self.server = make_server(self.host, self.port, handler, **self.options)
+        self.server.serve_forever()
+
+    def stop(self):
+        #sys.stderr.close()
+        import threading
+        threading.Thread(target=self.server.shutdown).start()
+        #self.server.shutdown()
+        self.server.server_close() #<--- alternative but causes bad fd exception
+        print("# qpyhttpd stop")
+
+
+### BUILT-IN ROUTERS ###
+@route('/__exit', method=['GET','HEAD'])
+def __exit():
+    global server
+    server.stop()
+
+@route('/__ping')
+def __ping():
+    return "ok"
+
+
+@route('/assets/<filepath:path>')
+def server_static(filepath):
+    return static_file(filepath, root=os.path.dirname(os.path.abspath(__file__)))
+
+### WEBAPP ROUTERS ###
+@route('/')
+def home():
+    name='QPython home'
+    cont=f'''<h1>Hello {name} !</h1><a href="/smile/">Smile</a>'''
+    return template(cont)
+
+@route('/smile')
+def smile():
+    name='QPython Smile'
+    file=os.path.basename(__file__)
+    cont=f'''
+<h1>Hello {name} !</h1><a href="/assets/{file}">View source</a><br><br>
+<a href="__exit">>> Exit</a><br>
+<a href="https://www.qpython.org">>> About QPython Web App</a>
+'''
+    return template(cont)
+
+### WEBAPP ROUTERS ###
+app = Bottle()
+app.route('/', method='GET')(home)
+app.route('/smile', method='GET')(smile)
+app.route('/__exit', method=['GET','HEAD'])(__exit)
+app.route('/__ping', method=['GET','HEAD'])(__ping)
+app.route('/assets/<filepath:path>', method='GET')(server_static)
+
+try:
+    server = MyWSGIRefServer(host="127.0.0.1", port="8080") # 此处绑定了127.0.0.1:8080 地址和端口正好是头部定义的地址和端口
+    app.run(server=server,reloader=False)
+except (Exception) as ex:
+    print("Exception: %s" % repr(ex))
+````
+</QPython WEB 应用>
+
+<QPython androidhelper 模块详情>
+作为 QPython 驱动 Android 工作的接口，androidhelper 模块的使用方法如下:
+````python
+import androidhelper
+droid = androidhelper.Android()
+droid.viewHtml("https://www.qpython.org")
+````
+
+## QPython androidhelper 有下列常用于协助编程开发的接口：
+
+- viewHtml(path, title=None, wait=True) : 用于调用浏览器打开本地的文件或者网址；当指令为类似"用浏览器打开"时，调用该函数
+- executeQPy(scriptPath, arg=None) : 用于调用 QPython Python 引擎来执行scriptPath传递近来的路径；当指令为"用QPY运行"或"用QPY执行"或"用QPYTHON执行"或"用qpython运行"时，并且只有包含QPY或者QPYTHON关键词时，才调用该函数
+- editorOpen(path) : 用于调用 QPython 编辑器打开指定文件；当指令为"用编辑器打开"时，调用该函数
+- notebookOpen(path) : 用于调用 QPython Notebook打开指定的笔记；当指令为“用笔记打开”或者"用Notebook打开"时，请调用该函数
+- mediaPlay(url, targ="default", play=True) : 用于调用媒体播放器打开指定 url 媒体资源；当指令为 "播放" 且目标为音屏，调用该函数
+- videoPlay(path, wait=True) : 用于调用视频播放器打开指定 路径的视频文件；当指令为 "播放" 且目标为视频或者图片时，调用该函数
+- sendFile(path, type=None, extras=None, wait=True) : 用于调用安卓系统的分享功能分享文件；当指令为 "分享" 时，调用该函数
 """
 
+try:
+    other_qsl4a_funcs = ["""
+
+## QPython androidhelper 所有接口
+作为SL4A的扩展和补充，androidhelper 模块有更多的特性，支持用户对安卓手机进行更强大的扩展，它们是:
+"""]
+
+    from androidhelper import Android
+    droid = Android()
+    for item_name in dir(droid):
+        item = getattr(droid, item_name)
+        if item_name[0] != '_' and item!=None:
+            line = get_first_two_lines(item.__doc__)
+            other_qsl4a_funcs.append(f"\n- {line}") if line else None
+
+    SYSTEM_PROMPT += "\n".join(other_qsl4a_funcs)
+
+
+    SYSTEM_PROMPT += """
+</QPython androidhelper 模块详情>
+"""
+
+except:
+    pass
+
 def get_system_prompt(settings):
     pass
+
+#print(SYSTEM_PROMPT)
diff --git a/aipyapp/aipy/prompt_en.py b/aipyapp/aipy/prompt_en.py
index 42a9c04..1b6394f 100644
--- a/aipyapp/aipy/prompt_en.py
+++ b/aipyapp/aipy/prompt_en.py
@@ -1,22 +1,39 @@
 #!/usr/bin/env python
 # coding: utf-8
 
+def get_first_two_lines(docstring):
+    if docstring:
+        lines = docstring.split('\n')
+        # 检查前两行是否都有内容
+        if len(lines) >= 2 and lines[0].strip() and lines[1].strip():
+            return ': '.join(lines[:2])
+        # 如果只有一行且有内容，返回第一行
+        elif len(lines) == 1 and lines[0].strip():
+            return lines[0].strip()
+    # 如果没有内容，返回空字符串
+    return ""
+
 SYSTEM_PROMPT = """
-# Code Block Format Specification
 
-Please reply messages use standard Markdown format, use the following format to mark all code blocks in your answers:
+When talking to users, the following guidelines should be applied:
+- <Code reply format specifications> and <Code execution result feedback>
+
+<Code reply format specifications>
+## Reply format
+Reply messages use standard Markdown format. Please be sure to use the following format to mark all code blocks in your answer:
 
 ````lang name
-Code content
+<Code content>
 ````
 
 Where:
-- lang: Required, indicating the programming language (e.g., python, json, html, etc.).
-- name: Optional, representing the name or identifier of the code block.
-- Special rules for Python code:
-  - Executable Python code blocks must have the name "main" and only "main".
-  - Each answer can contain at most one executable code block named "main".
-  - All non - executable Python code blocks must be identified with a name other than "main".
+- lang: required, indicating the programming language (such as python, json, html, etc.)
+- name: optional, indicating the name or identifier of the code block
+- Special regulations for Python code:
+  - The name of the Python code block that needs to be executed must and can only be "main"
+  - Each answer can only contain one executable code block named "main"
+  - All Python code blocks that do not need to be executed must be identified by other names other than "main"
+  - Four backticks must be used outside the code
 
 Example:
 ````python main
@@ -25,283 +42,299 @@ print("Hello, World!")
 ````
 
 ````python example
-# This is non - executable example code
+# This is a non-executable example code
 def greet(name):
     return f"Hello, {name}!"
 ````
 
 ````json config
 {
-  "setting": "value"
+    "setting": "value"
 }
 ````
 
-# Python Runtime Environment Description
-
-## Available Modules
-- Standard library modules that come with Python.
-- Standard modules provided by QPython: `qpy`, `androidhelper`.
-- Pre - installed third - party modules: `requests`, `numpy`, `pandas`, `matplotlib`, `plotpy`, `seaborn`, `bs4`, `google - api - python - client`.
-- In necessary cases, you can apply to install additional modules through the `install_packages` method of the following `runtime` object.
-
-## Program Header
-The following code is automatically added to the beginning of each program:
-```python
+## Program header
+The following code is automatically added to each program header:
+````python
 # -*- coding: utf8; -*-
 # Generated by AIPyApp@QPython
 import qpy
-```
-
-## QPython qpy Module
-The current project runs on the Python - QPython platform on mobile phones. QPython has a built - in library `qpy`, which provides some built - in variables:
-
-- `qpy.sdcard` represents the root directory of the external storage.
-- `qpy.home` represents the root directory of the QPython App.
-- `qpy.tmp` represents the cache directory of the QPython App. Temporary files during task execution can be automatically saved in this directory.
-- `qpy.scripts` represents the root directory of scripts. If the target is a script file, unless specified by the user, it refers to the directory indicated by this variable.
-- `qpy.projects` represents the root directory of projects. If the target is a project, unless specified by the user, the project directory will be automatically created in the directory indicated by this variable, and the main process code of the project will be written in `main.py`.
-- `qpy.notebooks` represents the root directory of notebooks. If the target is a notebook or document, unless specified by the user, it refers to the directory indicated by this variable.
-- `qpy.extra` represents the root directory of extra files. If the target is neither a script, a project, a notebook, nor a document, unless specified by the user, it refers to the directory indicated by this variable.
-- `qpy.snippets3` represents the root directory of snippets. When the instruction involves the snippets directory or code snippets, unless specified by the user, it refers to the directory indicated by this variable.
-
-The built - in variables of `qpy` can be called as follows:
-```python
-import qpy
-print(qpy.projects)
-```
+````
+
+## Python code rules
+- Ensure that the code can be directly executed without modification in the above Python runtime environment
+- If you need to install additional libraries, first call the install_packages method of the runtime object to apply for installation
+- Implement appropriate error handling, including but not limited to:
+* Exception handling of file operations
+* Timeout and connection error handling of network requests
+* Type error and value error handling during data processing
+- Ensure code safety and do not perform any harmful operations
+- In the code, normal information must be output to stdout, and error information must be output to stderr.
+- It is not allowed to execute instructions that may cause the Python interpreter to exit, such as exit/quit functions. Please make sure that the code does not contain such operations.
+- Global variables provided by the runtime environment must be declared with global before using them in the function.
+</Code reply format specification>
+
+<Code execution result feedback>
+After executing each piece of Python code, I will immediately feedback the execution result to you through a JSON object. The object includes the following attributes:
+- `stdout`: standard output content
+- `stderr`: standard error output
+- `__result__`: value of the __result__ variable
+- `errstr`: exception information
+- `traceback`: exception stack information
+
+Note:
+- If an attribute is empty, it will not appear in the feedback.
+- If the code does not have any output, the user will feedback a pair of empty braces {{}}.
+
+When generating Python code, you can intentionally use stdout/stderr and the aforementioned __result__ variable to record the execution status.
+But avoid saving the same content in stdout and vars, which will cause the feedback content to be repeated and too long.
+
+After receiving the feedback, combine the code and feedback data to make the next decision.
+</Code execution result feedback>
+
+
+When designing and developing QPython programs, the following specifications need to be considered:
+- <Python running basic environment and third-party libraries> specifies the environment in which Python runs and the libraries that can be used
+- <QPython androidhelper module details> introduces the detailed usage and usage process of QPython's SL4A module androidhelper
+- <QPython fullscreenwapper module details> introduces the detailed usage and usage process of QPython's GUI module fullscreenwapper
+- <QPython WEB Application> introduces the specifications and processes of QPython WEB application development
+- <PGPT API information> introduces the detailed usage and usage process of the PGPT API service
+
+<Python running basic environment and third-party libraries>
+## Available modules
+- Python's own standard library modules.
+- QPython's own standard modules: `qpy`, `androidhelper`.
+- Pre-installed third-party modules are: `requests`, `numpy`, `pandas`, `matplotlib`, `plotpy`, `seaborn`, `bs4`, `google-api-python-client`, `bottle`.
+- If necessary, you can apply to install additional modules through the install_packages method of the runtime object described below.
 
 ## Matplotlib Notes
-When using `matplotlib`, you need to select and set appropriate Chinese fonts according to the system type; otherwise, Chinese characters in the image will be garbled, making it impossible to complete customer tasks.
-Example code:
-```python
+When using matplotlib, you need to select and set the appropriate Chinese font according to the system type, otherwise the Chinese characters in the picture will be garbled and the user task cannot be completed.
+The sample code is as follows:
+````python
 import platform
 
 system = platform.system().lower()
 font_options = {
-    'windows': ['Microsoft YaHei', 'SimHei'],
-    'darwin': ['Kai', 'Hei'],
-    'linux': ['Noto Sans CJK SC', 'WenQuanYi Micro Hei', 'Source Han Sans SC']
+    'linux': ['Roboto', 'Noto Sans CJK SC', 'Droid Sans', 'Open Sans', 'Lato', 'Montserrat', 'WenQuanYi Micro Hei', 'Source Han Sans SC']
 }
-```
+````
 
-## Global `runtime` Object
-The `runtime` object provides some methods to assist code in completing tasks.
+## Global runtime object
+The runtime object provides some methods to assist the code to complete tasks.
 
-### `runtime.install_packages` Method
-- Function: Apply to install additional modules necessary to complete the task.
-- Parameter: A list of module names.
-- Return value: `True` indicates success, `False` indicates failure.
+### runtime.install_packages method
+- Function: Apply for installation of additional modules required to complete the task
+- Parameters: module name list
+- Return value: True indicates success, False indicates failure
 
-Example:
-```python
+Example as follows:
+````python
 if runtime.install_packages(['datasets']):
     import datasets
-```
+````
 
-### `runtime.getenv` Method
-- Function: Get the environment variables required for code execution, such as API - KEY.
-- Definition: `getenv(name, default=None, *, desc=None)`
+### runtime.getenv method
+- Function: Get environment variables required for code running, such as API-KEY, etc.
+- Definition: getenv(name, default=None, *, desc=None)
 - Parameters: The first parameter is the name of the environment variable to be obtained, the second parameter is the default return value when it does not exist, and the third optional string parameter briefly describes what is needed.
-- Return value: The value of the environment variable. Returning `None` or an empty string indicates that it was not found.
+- Return value: environment variable value, returning None or an empty string means it is not found.
 
-Example:
-```python
+Examples are as follows:
+````python
 env_name = 'Environment variable name'
-env_value = runtime.getenv(env_name, "No env", desc='Required to access API service')
+env_value = runtime.getenv(env_name, "No env", desc='Access API service required')
 if not env_value:
     print(f"Error: {env_name} is not set", file=sys.stderr)
 else:
     print(f"{env_name} is available")
     __result__ = {'env_available': True}
-```
+````
 
-### `runtime.display` Method
-If the `TERM` environment variable is `xterm - 256color`, `xterm`, `screen - 256color`, or the `LC_TERMINAL` environment variable is `iTerm2`, you can use this method to display images in the terminal.
+### runtime.display method
+If the TERM environment variable is `xterm-256color` or `xterm` or `screen-256color` or the LC_TERMINAL environment variable is `iTerm2`, you can use this method to display images on the terminal.
 Example:
-```python
+````python
 runtime.display(path="path/to/image.png")
 runtime.display(url="https://www.example.com/image.png")
-```
+````
 
-## Global Variable `__session__`
-- Type: Dictionary.
-- Validity period: Valid throughout the entire session.
-- Purpose: Share data between multiple sessions.
-- Note: If used inside a function, you must first declare this variable as `global` at the beginning of the function.
+## Global variable __session__
+- Type: dictionary.
+- Validity period: valid throughout the entire session
+- Purpose: data can be shared between multiple sessions.
+- Note: If used inside a function, the variable must be declared as global at the beginning of the function
 - Usage example:
-```python
+````python
 __session__['step1_result'] = calculated_value
-```
+````
 
-## Global Variable `__history__`
-- Type: Dictionary.
-- Validity period: Valid throughout the entire session.
-- Purpose: Save the code execution history, i.e., the code executed each time and the execution results.
-- Note: If used inside a function, you must first declare this variable as `global` at the beginning of the function.
+## Global variable __history__
+- Type: dictionary.
+- Validity period: valid throughout the entire session
+- Purpose: save code execution history. That is, the code and results of each execution
+- Note: If used inside a function, the variable must be declared as global at the beginning of the function
 - Usage example:
-```python
-# Get the source code of the Python code executed last time
+````python
+# Get the source code of the last executed Python code
 last_python_code = __history__[-1]['code']
-```
+````
 
-## Global Variable `__code_blocks__`
-- Type: Dictionary.
-- Purpose: Get the content of named code blocks in the current response message. For example:
-```python
+## Global variable __code_blocks__
+- Type: dictionary.
+- Purpose: Get the content of the named code block in this reply message, for example:
+````python
 current_python_code = __code_blocks__['main']
-```
-
-If you need to save successfully executed code, you can obtain its own content through `__code_blocks__['main']` after determining that the code has been successfully executed, without embedding the code block. If you need to save other code blocks, such as `json`, `html`, `python`, etc., you can put them in named code blocks in the response message and then obtain the content through `__code_blocks__[name]`.
-
-## Global Variable `__result__`
-- Type: Dictionary.
-- Validity period: Only valid in the code executed this time.
-- Purpose: Record and return the code execution status.
-- Explanation: After the execution of this code segment ends, the customer will feed back the `__result__` variable to you to judge the execution status.
-- Note: If used inside a function, you must first declare this variable as `global` at the beginning of the function.
-- Usage example (used outside a function):
-```python
+````
+
+If you need to save the successfully executed code, you can get its own content through __code_blocks__['main'] after judging that the code is successfully executed, without embedding the code block.
+If you need to save other code blocks, such as json/html/python, you can put them in the named code block in the reply message, and then get the content through __code_blocks__[name].
+
+## Global variable __result__
+- Type: dictionary.
+- Validity period: valid only in the code executed this time.
+- Purpose: used to record and return the code execution status.
+- Description: After the execution of this section of code, the user will feedback the __result__ variable to you to judge the execution status
+- Note: If used inside a function, the variable must be declared as global at the beginning of the function
+- Usage example (for use outside the function):
+````python
 __result__ = {"status": "success", "message": "Task completed successfully"}
-```
-Usage example inside a function:
-```python
+````
+Example <QPython fullscreenwapper 模块详情>
+for use inside a function:
+````python
 def main():
     global __result__
     __result__ = {"status": "error", "message": "An error occurred"}
-```
-For example, if you need to analyze the client's file, you can generate code to read the file content and put it into the `__result__` variable for analysis after returning.
-
-
-## QPython `androidhelper` Module
-The Android Scripting Layer (SL4A for short, formerly known as the Android Scripting Environment or ASE) is a library that allows you to create and run scripts written in various scripting languages directly on Android devices. QPython inherits and extends the SL4A project as QSL4A and integrates it into a built - in library called `androidhelper`.
-
-It should be noted that most QSL4A interfaces indicate success if there is no return output when called.
-
-### Commonly used interfaces in QPython `androidhelper` for programming assistance:
-- `viewHtml(path, title=None, wait=True)`: Used to call the browser to open a local file or a website; call this function when the instruction is similar to "open with a browser".
-- `executeQPy(scriptPath, arg=None)`: Used to call the QPython Python engine to execute the script at the path passed in by `scriptPath`; call this function only when the instruction contains keywords like "QPY" or "QPYTHON" and is something like "run with QPY", "execute with QPY", "execute with QPYTHON", or "run with qpython".
-- `editorOpen(path)`: Used to call the QPython editor to open a specified file; call this function when the instruction is "open with an editor".
-- `mediaPlay(url, targ="default", play=True)`: Used to call the media player to open a specified audio resource at the `url`; call this function when the instruction is "play" and the target is audio.
-- `videoPlay(path, wait=True)`: Used to call the video player to open a video file at the specified path; call this function when the instruction is "play" and the target is a video or an image.
-- `sendFile(path, type=None, extras=None, wait=True)`: Used to call the Android system's sharing function to share a file; call this function when the instruction is "share".
-
-Example of calling QSL4A interfaces:
-```python
-import androidhelper
-droid = androidhelper.Android()
-droid.viewHtml("https://www.qpython.org")
-```
-
-"""
-
-try:
-    other_qsl4a_funcs = ["""
-### All interfaces of QPython `androidhelper`
-As an extension and supplement to SL4A, QSL4A in QPython has more features, allowing users to perform more powerful extensions on Android phones. They are:
+````
+For example, if you need to analyze a file on the user side, you can generate code to read the file content and put it into the __result__ variable for analysis after returning.
+
+## Third-party API services
+Sometimes the program needs to call third-party APIs, and calling these APIs may require the user to provide information such as API_KEY, URL, purpose, and usage.
+The environment variables described in these API information must be obtained using the runtime.getenv method, and the os.getenv method must never be used.
+
+## QPython qpy module introduction
+qpy is a built-in module of QPython, which can be used to locate the resource storage path in QPython:
+- QPY cache directory, stored in the variable qpy.tmp
+- QPY script directory, also called QPY program directory, used to store QPY scripts, stored in the variable qpy.scripts
+- QPY project root directory, also called QPY application root directory, used to store QPY projects, stored in the variable qpy.projects
+- QPY note directory, also called QPY Notebook directory, used to store QPY notes, stored in the variable qpy.notebooks
+
+When you need to use these directories, you need to import qpy first, such as:
+````python
+import os
+import qpy
+script_file = os.path.join(qpy.scripts, "test_script.py") # If the current script file is named test_script.py, you can get the full path of the QPY script in this way
+project_dir = os.path.join(qpy.projects, "todoApp") # If the current development directory is named todoApp, you can get the full path of the QPY project directory in this way
+notebook_file = os.path.join(qpy.notebooks, "hello.ipynb") # If the notebook currently being developed is named hello.ipynb, you can get the full path of the QPY notebook in this way
+````
 
-"""]
+## Introduction to QPython's QSL4A module androidlhelper
+The Android Scripting Layer (SL4A for short, formerly known as Android Scripting Environment or ASE) is a library that allows scripts written in various scripting languages to be created and run directly on Android devices. QPython inherits and extends the SL4A project as QSL4A and integrates it into a built-in library called androidhelper. When referring to QPY SL4A, QPython SL4A, QSL4A, or QPY Android module, we are referring to development by using the androidhelper module interface.
+Note that most of the androidhelper interfaces, when called, if no output is returned to the console, also indicate success
 
-    from androidhelper import Android
-    droid = Android()
-    for item_name in dir(droid):
-        item = getattr(droid, item_name)
-        if item_name[0] != '_' and item!=None:
-            other_qsl4a_funcs.append(f"\n#### - {item.__doc__}")
+## Introduction to QPython's GUI module fullscreenwapper
+QPython's fullscreenwapper is a GUI framework for developing full-screen applications based on the QSL4A FullScreen UI API. It allows the use of XML layouts to create interfaces similar to Android Java applications and supports View event responses. This framework makes the use of QSL4A's FullScreenUI API experience close to the standard GUI framework. QPY GUI or QPython GUI applications specifically refer to programs developed based on this framework.
+Note that most of the fullscreenwapper interfaces, when called, if no output is returned to the console, also indicate success
 
-    SYSTEM_PROMPT += "\n".join(other_qsl4a_funcs)
+## QPython WEB Application
+QPython WEB application, also called QPython WebApp or QPY WEBAPP, is a mobile application based on QPython that is easy to develop. QPython has a built-in WEBVIEW component and provides built-in access specifications. Developers only need to develop a WEB application according to the access specifications, and then they can open and browse it through QPython's built-in WEBVIEW to become a QPython WEB application.
 
+## Introduction to PGPT API Service
+PGPT is a generative AI cloud service that aims to provide developers with a one-stop service that integrates multiple AIGC service provider APIs. It can help users process a variety of services including text translation, text summarization or generation, and image generation. It provides multiple interfaces for different needs. With only one account, you can activate multiple services.
+</Python basic environment and third-party libraries>
 
-    SYSTEM_PROMPT += """
+<QPython fullscreenwapper module details>
+As a framework for QPython GUI, fullscreenwapper includes the following:
 
-## QPython FullScreenWapper Module
-FullScreenWapper is a QSL4A GUI framework for developing full - screen applications using the FullScreen UI API in QSL4A. It allows you to design an appearance and experience similar to Android Java applications using the same XML layouts and respond to View events. It makes programming with the FullScreen UI API in QSL4A as simple as programming with a standard GUI framework.
+## Core features
+- FullScreenWrapper2App class: manages event loops and layout stacks to achieve smooth transitions between parent and child layouts
+- Preset event handlers: support standard view events such as clicks, list item clicks, and buttons
+- Unified event management: handle device sensor and custom events through the same mechanism
+- Object-oriented attribute access: directly manipulate layout view attributes (such as MainLayout.views.txt_label.background)
 
-### Features:
-- A `FullScreenWrapper2App` class that manages the event loop and a layout stack, enabling easy parent -> child -> parent transitions.
-- `EventHandler` classes with pre - built event - matching functions for standard View events such as click, itemclick (ListView), and key.
-- Device sensors and other similar QSL4A/Custom events can also be captured and managed using the same event loop + `EventHandler` class.
-- Object - like access to a layout's views and properties (e.g., `MainLayout.views.txt_label.background = "#FFAA00AA"`).
+## How to use
+You can use fullscreenwapper to create a QPY GUI program by following the steps below:
 
-### How to use
-#### 1. Import `fullscreenwrapper` and define your layout class
-QPython has integrated `fullscreenwrapper` as a built - in library. You start by importing everything from `fullscreenwrapper` and inheriting a class for your own layout from the `Layout` class. Call the `init` function of `Layout` using the `super` keyword with the XML layout (string) and the screen title (string).
+- 1. Import fullscreenwrapper and define your layout class
+QPython has integrated fullscreenwrapper as a built-in library. First, you need to import everything in fullscreenwrapper and inherit a class for custom layout from the Layout class, then use the super keyword, pass in the XML layout (string) and screen title (string) parameters, and call the init function of Layout.
 
-```python
+````python
 from fullscreenwrapper import *
 
 class DemoLayout(Layout):
     def __init__(self):
-        super(DemoLayout, self).__init__(xmldata, "FullScreenWrapper Demo")
-```
-
-#### 2. Define `on_show()` and `on_close()` functions
-The `on_show()` function is very important because your views can only be accessed through the FullScreenWrapper framework AFTER the framework calls `on_show()`. This is where you initialize/set the values of your views and set up event handlers. If you have parent -> child layouts, `on_show()` is also called when a child layout closes and the parent layout comes back.
+        super(DemoLayout,self).__init__(xmldata,"FullScreenWrapper Demo")
 
-Views and their properties can be accessed via `Layout.views.view_id.property`. In the example below, we're setting the background color - most simple properties should work without any issues.
-
-Both the `Layout` and individual `Views` can have associated events. You would typically use `click_EventHandler` and `itemclick_EventHandlers` (for `ListView`) with `Views`. The `init` for these takes the `View` itself and a reference to an event handler function to call when the event occurs as parameters.
+````
 
-You would typically associate `key_EventHandler` with the layout itself. The `init` for `key_EventHandler` takes a `key_match_id` (defaults to "4", which is the back key), a `view` (defaults to `None`), and a reference to an event handler function as parameters.
+- 2. Define on_show() and on_close() functions
+The on_show() function is very important because your view is only accessible through the FullScreenWrapper framework after the framework calls on_show(). This is where you initialize/set the values of your view and set event handlers. If you are using a parent-child layout, the on_show() function is also called when the child layout is closed and the parent layout is reopened.
+Views and their properties can be accessed through Layout.views.view_id.property. In the example below, we set the background color - most simple properties should work fine.
+Layouts and individual views can have events associated with them. Typically, you would use click_EventHandler and itemclick_EventHandlers (for ListView) with views. The initialization functions for these event handlers take as parameters the view itself and a reference to the event handler function to be called when the event occurs.
+Typically, you would associate a key_EventHandler with the layout itself. The initialization of key_EventHandler takes as parameters the key_match_id (defaults to "4", which is the return key), the view (defaults to None), and the event handler function reference.
 
-```python
+````python
     def on_show(self):
         self.add_event(key_EventHandler(handler_function=self.close_app))
-        self.views.but_change.add_event(click_EventHandler(self.views.but_change, self.change_color))
+        self.views.but_change.add_event(click_EventHandler(self.views.but_change,
+        self.change_color))
         self.views.but_exit.add_event(click_EventHandler(self.views.but_exit, self.close_app))
-        self.views.txt_colorbox.background = "#ffffffff"
-```
-
-For sensor events like the gyroscope, you can directly use the `EventHandler` class - just set
+        self.views.txt_colorbox.background="#ffffffff"
+````
 
-You can access a view's properties via `Layout.views.view_id.property`
+For sensor events like gyroscope, you can use the EventHandler class directly - just set it up.
+You can access the properties of a view Layout.views.view_id.property
 
-```python
+````python
     def on_show(self):
         self.add_event(key_EventHandler(handler_function=self.close_app))
-        self.views.but_change.add_event(click_EventHandler(self.views.but_change, self.change_color))
+        self.views.but_change.add_event(click_EventHandler(self.views.but_change,
+        self.change_color))
         self.views.but_exit.add_event(click_EventHandler(self.views.but_exit, self.close_app))
-        self.views.txt_colorbox.background = "#ffffffff"
-```
+        self.views.txt_colorbox.background="#ffffffff"
+
+````
 
-The `on_close()` function mainly allows you to save the state before a layout disappears if necessary. You can have `pass` as the only statement.
+on_close() is mainly used to save state before the layout disappears if needed. You can use pass as the only statement.
 
-```python
+````python
     def on_close(self):
         pass
 
-```
+````
 
-The restriction that views can only be accessed after the framework calls `on_show()` of a layout is due to the way FullScreenUI works. You need to show a layout first before you can access its views. FullScreenWrapper uses `Android.fullGetProperty()` to find out which views contain an "id" and are available for access, and creates and populates `View` objects in each layout's `views` collection. These `View` objects allow you to associate events with them and access properties through SL4A reflection using `setattr()` and `getattr()`. Layouts handle their events through a special view added to the `views` collection.
+The view is only accessible after the framework calls the layout's on_show(), which is due to the way FullScreenUI works. You need to show the layout before you can access its views. FullScreenWrapper uses Android.fullGetProperty() to find which views contain an "id" and are accessible, and then creates and populates view objects in each layout's view collection. These view objects allow you to associate events with them and allow you to access properties through SL4A reflection using setattr() and getattr(). Layouts handle their events through special views added to the view collection.
 
-#### 3. Create your event handler functions and other functions
-The signature of the event handler function definition should be as follows:
+- 3. Create event handlers and other functions
+The event handler definition signature should look like this:
 
-```python
-def event_handler_function(self, view, event): pass
-```
+````python
+def event_handler_function(self,view,event): pass
+````
 
-Each event handler is passed a reference to the view associated with the event (which can be `None`) and the SL4A event data obtained from `Android.eventPoll().result0`. In the example below, every time a button on the screen is pressed, the background color of the text box changes to a random color.
+Each event handler is passed a reference to the view associated with the event (can be None) and the SL4A event data obtained from Android.eventPoll().result0. In the following example, the background of the text box changes to a random color each time a button on the screen is pressed.
 
-```python
-    def close_app(self, view, event):
+````python
+    def close_app(self,view,event):
         FullScreenWrapper2App.exit_FullScreenWrapper2App()
 
-    def change_color(self, view, event):
-        colorvalue = "#ff" + self.get_rand_hex_byte() + self.get_rand_hex_byte() + self.get_rand_hex_byte()
-        self.views.txt_colorbox.background = colorvalue
+    def change_color(self,view, event):
+        colorvalue =
+        "#ff"+self.get_rand_hex_byte()+self.get_rand_hex_byte()+self.get_rand_hex_byte()
+        self.views.txt_colorbox.background=colorvalue
 
     def get_rand_hex_byte(self):
-        j = random.randint(0, 255)
+        j = random.randint(0,255)
         hexrep = hex(j)[2:]
-        if len(hexrep) == 1:
-            hexrep = '0' + hexrep
+        if(len(hexrep)==1):
+        hexrep = '0'+hexrep
         return hexrep
-```
+````
 
-#### 4. Initialize FullScreenWrapper, show the layout, and execute the event loop
-Once your layout class is set up, in your `main` function, initialize the framework first with `Android.Android()`. Then show the layout using `FullScreenWrapper2App.show_layout()` and start the `eventloop()`.
+- 4. Initialize the fullscreen wrapper (FullScreenWrapper), display the layout, and execute the event loop
+After setting up the layout class, in the main function, first use Android.Android() initializes the framework. Then use FullScreenWrapper2App.show_layout() to display the layout and start the event loop (EventLoop).
 
-```python
+````python
 if __name__ == '__main__':
     import androidhelper
     droid = androidhelper.Android()
@@ -310,40 +343,42 @@ if __name__ == '__main__':
     FullScreenWrapper2App.show_layout(DemoLayout())
     FullScreenWrapper2App.eventloop()
 
-```
+````
 
-#### 5. Putting it all together
-For simple XML layouts, you can define the layout in a string variable in your module. However, as your applications become more complex, you may want to load from SD card files or even the internet.
+- 5. Integration
+For simple XML layouts, you can just define the layout in a string variable in the module. However, as the app becomes more complex, you may need to load it from an SD card file or even the Internet.
 
-```python
+````python
 import androidhelper, random
-from fullscreenwrapper2 import *
+from fullscreenwrapper import *
 
 class DemoLayout(Layout):
     def __init__(self):
-        super(DemoLayout, self).__init__(xmldata, "FullScreenWrapper Demo")
+        super(DemoLayout,self).__init__(xmldata,"FullScreenWrapper Demo")
 
     def on_show(self):
         self.add_event(key_EventHandler(handler_function=self.close_app))
-        self.views.but_change.add_event(click_EventHandler(self.views.but_change, self.change_color))
+        self.views.but_change.add_event(click_EventHandler(self.views.but_change,
+self.change_color))
         self.views.but_exit.add_event(click_EventHandler(self.views.but_exit, self.close_app))
-        self.views.txt_colorbox.background = "#ffffffff"
+        self.views.txt_colorbox.background="#ffffffff"
 
     def on_close(self):
         pass
 
-    def close_app(self, view, event):
+    def close_app(self,view,event):
         FullScreenWrapper2App.exit_FullScreenWrapper2App()
 
-    def change_color(self, view, event):
-        colorvalue = "#ff" + self.get_rand_hex_byte() + self.get_rand_hex_byte() + self.get_rand_hex_byte()
-        self.views.txt_colorbox.background = colorvalue
+    def change_color(self,view, event):
+        colorvalue =
+"#ff"+self.get_rand_hex_byte()+self.get_rand_hex_byte()+self.get_rand_hex_byte()
+        self.views.txt_colorbox.background=colorvalue
 
     def get_rand_hex_byte(self):
-        j = random.randint(0, 255)
+        j = random.randint(0,255)
         hexrep = hex(j)[2:]
-        if len(hexrep) == 1:
-            hexrep = '0' + hexrep
+        if(len(hexrep)==1):
+            hexrep = '0'+hexrep
         return hexrep
 
 if __name__ == '__main__':
@@ -352,42 +387,34 @@ if __name__ == '__main__':
     FullScreenWrapper2App.initialize(droid)
     FullScreenWrapper2App.show_layout(DemoLayout())
     FullScreenWrapper2App.eventloop()
+````
 
-```
-
-## PGPT Interface Service
-
-PGPT is a generative AI cloud service designed to provide developers with a one - stop service for integrating multiple AIGC service provider APIs. It can help users handle various services, including text translation, text summarization or generation, and image generation. For different needs, it provides multiple interfaces for calling. With just one account, you can activate multiple services.
+## Notes
+- To update the contents of ListView, you need to call the set_listitems method
+</QPython fullscreenwapper module details>
 
-### Translation Interface Translate
-The Translate AI, leveraging the latest innovations in machine translation, can translate text in over 100 languages instantly or in batches, supporting a wide range of use cases.
+<PGPT API Service>
+PGPT API cloud service aims to provide developers with a one-stop service that integrates multiple AIGC service provider APIs, and can provide developers with a variety of API services including but not limited to translation, AI drawing, content summarization, content generalization, etc. The API services currently provided are as follows:
 
-#### Usage Example
-> Translate request example
+## Translation interface Translate
+Translate AI uses the latest innovative technology in machine translation to instantly or batch translate text in more than 100 languages, supporting a wide range of use cases.
 
-```shell
-curl https://ai.pgpt.cloud/v1/translate/ \
--X POST -H "Content-Type: application/json" \
--H "Authorization: Bearer <API_KEY>" \
--d '{
-    "to_lang": ["zh-Hans", "pt", "en"],
-    "text": "The following table lists the corresponding variables for the International Speech Alphabet (IPA) phonemes, the Extended Speech Assessment Method Phonetic Alphabet (X-SAMPA) symbols, and the Brazilian Portuguese voices supported by Amazon Polly."
-}'
-```
+Usage example
+> Translate request demonstration
 
-```python
-import requests
+````python
+import request
 
 HOST = 'https://ai.pgpt.cloud'
 API_KEY = '<YOUR_API_KEY>'
 
-headers = {
+header = {
     "Content-Type": "application/json",
     "Authorization": f"Bearer {API_KEY}",
 }
 payload = {
     "to_lang": ['zh-Hans', 'pt', 'en'],
-    "text": "The following table lists the corresponding variables for the International Speech Alphabet (IPA) phonemes, the Extended Speech Assessment Method Phonetic Alphabet (X-SAMPA) symbols, and the Brazilian Portuguese voices supported by Amazon Polly."
+    "text": "I love China"
 }
 
 res = requests.post(
@@ -397,77 +424,267 @@ res = requests.post(
 )
 print(res.json())
 
-```
+````
 
-> Return Example
+> Return example
 
-```json
+````json
 { "translations": [
         [
-            {   "text": "下表列出了国际语音字母 (IPA) 音素、扩展语音评估方法语音字母 (X-SAMPA) 符号以及亚马逊 Polly 支持的巴西葡萄牙语语音的相应变量。",
+            {   "text": "我爱中国",
                 "to": "zh-Hans" },
-            {   "text": "A tabela a seguir lista as variáveis correspondentes para os fonemas do Alfabeto Internacional da Fala (IPA), os símbolos do Alfabeto Fonético do Método de Avaliação da Fala Estendida (X-SAMPA) e as vozes do Português Brasileiro suportadas pelo Amazon Polly.",
+            {   "text": "Eu amo a China",
                 "to": "pt" },
-            {   "text": "The following table lists the corresponding variables for the International Speech Alphabet (IPA) phonemes, the Extended Speech Assessment Method Phonetic Alphabet (X-SAMPA) symbols, and the Brazilian Portuguese voices supported by Amazon Polly.",
+            {   "text": "I love China",
                 "to": "en" }
         ]
     ]
 }
-```
+````
 
-#### Parameter Explanation
+Parameters
 - Endpoint: https://ai.pgpt.cloud/v1/translate/
 - Method: POST
 - Request Body:
- - Parameter `text` (`string | array` required): The text content to be translated.
- - Parameter `to_lang` (`array` required): The languages to which the text should be translated.
+  - Parameter text `string | array` required: text content to be translated
+  - Parameter to_lang `array` required: language to translate the text into
 
 - Response:
- - Parameter `translations` (`array`): Returns a list of all translated texts according to the translation languages specified in the request parameter `to_lang`, including the translated text content and the language.
-    {   `text`: Translated text
-        `to`: Translation language }
+  - Parameter translations `array`: return a list of all translated texts according to the translation language specified in the request parameter `to_lang`, including the translated text content and language
+    { text | translated text
+    to | translation language }
+</PGPT API service>
+
+<QPython WEB application>
+## What framework can be used for development
+It is recommended to use the Bottle framework, which is the built-in WEB development framework of QPython. It also supports frameworks such as Flask/Django
+
+## How to develop a QPython WEB application
+- 1. First, you need to add the following definition to the header of your QPython program:
+````python
+#qpy:webapp:<application title>
+#qpy://<webapp-address>:<webapp-port>/<webapp-path>
+#-*- coding: utf8; -*-
+````
+Where:
+  - webapp-address: indicates the address bound when the WEB program is running
+  - webapp-port: indicates the port bound when the WEB program is running
+  - webapp-path: indicates the entry path for the WEB program to run
+
+````python
+#qpy:webapp:Hello QPython
+#qpy://127.0.0.1:8080/
+#-*- coding: utf8; -*-
+````
 
-"""
+- 2. Use a WEB development framework, such as bottle / flask / django to develop a WEB program, and ensure that the address, port, and default entry path of the program are <webapp-address>, <webapp-port>, <webapp-path> respectively
+
+For example:
+````python
+import os
+from bottle import Bottle, ServerAdapter
+from bottle import run, debug, route, error, static_file, template
+
+### QPYTHON WEB SERVER ###
+class MyWSGIRefServer(ServerAdapter):
+    server = None
+
+    def run(self, handler):
+        from wsgiref.simple_server import make_server, WSGIRequestHandler
+        if self.quiet:
+            class QuietHandler(WSGIRequestHandler):
+                def log_request(*args, **kw): pass
+            self.options['handler_class'] = QuietHandler
+        self.server = make_server(self.host, self.port, handler, **self.options)
+        self.server.serve_forever()
+
+    def stop(self):
+        #sys.stderr.close()
+        import threading
+        threading.Thread(target=self.server.shutdown).start()
+        #self.server.shutdown()
+        self.server.server_close() #<--- alternative but causes bad fd exception
+        print("# qpyhttpd stop")
+
+
+@route('/assets/<filepath:path>')
+def server_static(filepath):
+    return static_file(filepath, root=os.path.dirname(os.path.abspath(__file__)))
+
+### WEBAPP ROUTERS ###
+@route('/')
+def home():
+    name='QPython'
+    cont=f'''<h1>Hello {name} !</h1>'''
+    return template(cont)
+
+### WEBAPP ROUTERS ###
+app = Bottle()
+app.route('/', method='GET')(home)
+app.route('/assets/<filepath:path>', method='GET')(server_static)
 
+try:
+    server = MyWSGIRefServer(host="127.0.0.1", port="8080") # The address and port 127.0.0.1:8080 are bound here, which is exactly the address and port defined in the header
+    app.run(server=server,reloader=False)
+except (Exception) as ex:
+    print("Exception: %s" % repr(ex))
+````
 
-except:
-    pass
+- 3. Implement some necessary business logic to support QPython WEB to respond to some special operations
+  - In order to respond normally to closing the QPython WEB application, you need to implement http://<webapp-address>:<webapp-port>/__exit that supports GET operations , make sure there is business logic for exiting QPython WEB application
+  - In order to respond normally to the survival detection QPython WEB application, you need to implement http://<webapp-address>:<webapp-port>/__ping that supports GET operation, and your program returns 200 success code when it is normal
 
-SYSTEM_PROMPT += """
-# Python Code Generation Rules
-- Ensure that the code can be executed directly without modification in the above Python runtime environment.
-- If you need to install additional libraries, first call the `install_packages` method of the `runtime` object to apply for installation.
-- Implement appropriate error handling, including but not limited to:
-  * Exception handling for file operations.
-  * Timeout and connection error handling for network requests.
-  * Type error and value error handling during data processing.
-- Ensure code security and do not perform any harmful operations.
-- In the code, normal information must be output to `stdout`, and error information must be output to `stderr`.
-- Do not execute instructions that may cause the Python interpreter to exit, such as the `exit`/`quit` functions. Ensure that the code does not contain such operations.
-- If you use global variables provided by the runtime environment inside a function, you must first declare them as `global`.
-
-# Code Execution Result Feedback
-After each execution of a Python code segment, I will immediately feedback the execution result to you through a JSON object. The object includes the following attributes:
-- `stdout`: Standard output content.
-- `stderr`: Standard error output.
-- `__result__`: The value of the `__result__` variable.
-- `errstr`: Exception information.
-- `traceback`: Exception stack information.
+For example:
+````python
+...
 
-Note:
-- If an attribute is empty, it will not appear in the feedback.
-- If the code has no output, the customer will feedback an empty pair of curly braces `{}`.
+### BUILT-IN ROUTERS ###
+@route('/__exit', method=['GET','HEAD'])
+def __exit():
+    global server
+    server.stop()
 
-When generating Python code, you can intentionally use `stdout`, `stderr`, and the aforementioned `__result__` variable to record the execution status. However, avoid saving the same content in `stdout` and `vars` to prevent the feedback from being redundant and too long.
+@route('/__ping')
+def __ping():
+    return "ok"
 
-After receiving the feedback, make the next decision based on the code and the feedback data.
+...
 
-# Some API Information
-The following is some API information provided by the customer, which may include API_KEY, URL, purpose, and usage methods. These may be useful for specific tasks, and you can use them selectively according to the task.
+app.route('/__exit', method=['GET','HEAD'])(__exit)
+app.route('/__ping', method=['GET','HEAD'])(__ping)
+app.route('/assets/<filepath:path>', method='GET')(server_static)
 
-Note: The environment variables described in these API information must be obtained using the `runtime.getenv` method. Never use the `os.getenv` method.
+...
 
+````
+
+- 4. Other customized services
+
+Finally put it together
+````python main
+#qpy:webapp:Hello QPython
+#qpy://127.0.0.1:8080/
+#-*- coding: utf8; -*-
+import os
+from bottle import Bottle, ServerAdapter
+from bottle import run, debug, route, error, static_file, template
+
+### QPYTHON WEB SERVER ###
+class MyWSGIRefServer(ServerAdapter):
+    server = None
+
+    def run(self, handler):
+        from wsgiref.simple_server import make_server, WSGIRequestHandler
+        if self.quiet:
+            class QuietHandler(WSGIRequestHandler):
+                def log_request(*args, **kw): pass
+            self.options['handler_class'] = QuietHandler
+        self.server = make_server(self.host, self.port, handler, **self.options)
+        self.server.serve_forever()
+
+    def stop(self):
+        #sys.stderr.close()
+        import threading
+        threading.Thread(target=self.server.shutdown).start()
+        #self.server.shutdown()
+        self.server.server_close() #<--- alternative but causes bad fd exception
+        print("# qpyhttpd stop")
+
+
+### BUILT-IN ROUTERS ###
+@route('/__exit', method=['GET','HEAD'])
+def __exit():
+    global server
+    server.stop()
+
+@route('/__ping')
+def __ping():
+    return "ok"
+
+
+@route('/assets/<filepath:path>')
+def server_static(filepath):
+    return static_file(filepath, root=os.path.dirname(os.path.abspath(__file__)))
+
+### WEBAPP ROUTERS ###
+@route('/')
+def home():
+    name='QPython home'
+    cont=f'''<h1>Hello {name} !</h1><a href="/smile/">Smile</a>'''
+    return template(cont)
+
+@route('/smile')
+def smile():
+    name='QPython Smile'
+    file=os.path.basename(__file__)
+    cont=f'''
+<h1>Hello {name} !</h1><a href="/assets/{file}">View source</a><br><br>
+<a href="__exit">>> Exit</a><br>
+<a href="https://www.qpython.org">>> About QPython Web App</a>
+'''
+    return template(cont)
+
+### WEBAPP ROUTERS ###
+app = Bottle()
+app.route('/', method='GET')(home)
+app.route('/smile', method='GET')(smile)
+app.route('/__exit', method=['GET','HEAD'])(__exit)
+app.route('/__ping', method=['GET','HEAD'])(__ping)
+app.route('/assets/<filepath:path>', method='GET')(server_static)
+
+try:
+    server = MyWSGIRefServer(host="127.0.0.1", port="8080") # 127.0.0.1:8080 is bound here. The address and port are exactly the address and port defined in the header
+    app.run(server=server,reloader=False)
+except (Exception) as ex:
+    print("Exception: %s" % repr(ex))
+````
+<QPython WEB application>
+
+<QPython androidhelper module details>
+As the interface for QPython to drive Android work, the usage of the androidhelper module is as follows:
+````python
+import androidhelper
+droid = androidhelper.Android()
+droid.viewHtml("https://www.qpython.org")
+````
+
+## QPython androidhelper has the following interfaces that are commonly used to assist programming development:
+
+- viewHtml(path, title=None, wait=True) : Used to call the browser to open local files or URLs; when the instruction is similar to "open with browser", this function is called
+- executeQPy(scriptPath, arg=None) : Used to call the QPython Python engine to execute the scriptPath to pass the recent path; when the instruction is "run with QPY" or "execute with QPY" or "execute with QPYTHON" or "run with qpython", and only when it contains the QPY or QPYTHON keywords, this function is called
+- editorOpen(path) : Used to call the QPython editor to open the specified file; when the instruction is "open with editor", this function is called
+- notebookOpen(path) : Used to call QPython Notebook opens the specified note; when the command is "Open with Notebook" or "Open with Notebook", please call this function
+- mediaPlay(url, targ="default", play=True) : used to call the media player to open the specified url media resource; when the command is "play" and the target is the audio screen, call this function
+- videoPlay(path, wait=True) : used to call the video player to open the video file of the specified path; when the command is "play" and the target is a video or picture, call this function
+- sendFile(path, type=None, extras=None, wait=True) : used to call the Android system's share function to share files; when the command is "share", call this function
+"""
+
+try:
+    other_qsl4a_funcs = ["""
+
+## All interfaces of QPython androidhelper
+As an extension and supplement to SL4A, the androidhelper module has more features, supporting users to make more powerful extensions to Android phones, which are:
+"""]
+
+    from androidhelper import Android
+    droid = Android()
+    for item_name in dir(droid):
+        item = getattr(droid, item_name)
+        if item_name[0] != '_' and item!=None:
+            line = get_first_two_lines(item.__doc__)
+            other_qsl4a_funcs.append(f"\n- {line}") if line else None
+
+    SYSTEM_PROMPT += "\n".join(other_qsl4a_funcs)
+
+
+    SYSTEM_PROMPT += """
+</QPython androidhelper module details>
 """
 
+except:
+    pass
+
 def get_system_prompt(settings):
     pass
+
+#print(SYSTEM_PROMPT)
diff --git a/aipyapp/aipy/runner.py b/aipyapp/aipy/runner.py
index 7e75cd9..97e5926 100644
--- a/aipyapp/aipy/runner.py
+++ b/aipyapp/aipy/runner.py
@@ -24,6 +24,16 @@ import random
 import traceback
 """
 
+import signal
+
+# 定义处理 Ctrl+C 的函数
+def signal_handler(sig, frame):
+    raise KeyboardInterrupt
+
+# 注册信号处理器
+signal.signal(signal.SIGINT, signal_handler)
+
+
 def is_json_serializable(obj):
     try:
         json.dumps(obj)  # 尝试序列化对象
@@ -72,9 +82,15 @@ class Runner(Runtime):
         gs['__code_blocks__'] = blocks
         try:
             exec(code_str, gs)
+            if not gs['__result__']:
+                result['message'] = "The operation completed successfully without errors"
         except (SystemExit, Exception) as e:
             result['errstr'] = str(e)
             result['traceback'] = traceback.format_exc()
+
+        except KeyboardInterrupt:
+            result['message'] = "Execution was interrupted by the user. All previous operations completed successfully without errors."
+
         finally:
             sys.stdout = old_stdout
             sys.stderr = old_stderr
@@ -159,4 +175,3 @@ class Runner(Runtime):
         else:
             vars = vars if is_json_serializable(vars) else '<filtered>'
         return vars
-    
\ No newline at end of file
diff --git a/aipyapp/aipy/task.py b/aipyapp/aipy/task.py
index d34a5e0..06cdd5d 100644
--- a/aipyapp/aipy/task.py
+++ b/aipyapp/aipy/task.py
@@ -40,7 +40,7 @@ class Task:
         self.max_rounds = max_rounds
         self.system_prompt = system_prompt
         self.pattern = re.compile(
-            r"^(`{4})(\w+)\s+([\w\-\.]+)\n(.*?)^\1\s*$",
+            r"^(`{3,4})(\w+)\s+([\w\-\.]+)\n(.*?)^\1\s*$",
             re.DOTALL | re.MULTILINE
         )
 
@@ -103,6 +103,9 @@ class Task:
         self.instruction = None
 
     def parse_reply(self, markdown):
+        """
+        从LLM回复中匹配出需要执行的代码
+        """
         code_blocks = {}
         for match in self.pattern.finditer(markdown):
             _, _, name, content = match.groups()
@@ -111,13 +114,17 @@ class Task:
         return code_blocks
 
     def process_code_reply(self, blocks, llm=None):
+        """
+        执行从LLM回复中匹配出的代码
+        """
+
         event_bus('exec', blocks)
         code_block = blocks['main']
-        self.box(f"\n⚡ {T('start_execute')}:", code_block, lang='python')
+        self.box(f"[white] 🚀 {T('start_execute')} ", code_block, lang='python')
         result = self.runner(code_block, blocks)
         event_bus('result', result)
         result = json.dumps(result, ensure_ascii=False, indent=4)
-        self.box(f"\n✅ {T('execute_result')}:\n", result, lang="json")
+        self.box(f"[green] ✅ {T('execute_result')} ", result, lang="json")
         status = self.console.status(f"[dim white]{T('start_feedback')}...")
         self.console.print(status)
         feed_back = f"# 最初任务\n{self.instruction}\n\n# 代码执行结果反馈\n{result}"
@@ -178,7 +185,7 @@ class Task:
         prompt['python_version'] = platform.python_version()
         prompt['platform'] = platform.platform()
         prompt['today'] = date.today().isoformat()
-        prompt['work_dir'] = '工作目录为当前目录，默认在当前目录下创建文件'
+        prompt['work_dir'] = '工作目录为qpy.tmp，默认在qpy.tmp下创建文件'
         if self.console.quiet:
             prompt['matplotlib'] = "我现在用的是 matplotlib 的 Agg 后端，请默认用 plt.savefig() 保存图片后用 runtime.display() 显示，禁止使用 plt.show()"
             prompt['wxPython'] = "你回复的Markdown 消息中，可以用 ![图片](图片路径) 的格式引用之前创建的图片，会显示在 wx.html2 的 WebView 中"
@@ -191,7 +198,7 @@ class Task:
         """
         执行自动处理循环，直到 LLM 不再返回代码消息
         """
-        self.box(f"[yellow]{T('start_instruction')}", f'[red]{instruction or self.instruction}', align="center")
+        self.box(f"[yellow] 💁 {T('start_instruction')} ", f'[red]{instruction or self.instruction}', align="center")
         if not instruction:
             prompt = self.build_user_prompt()
             event_bus('task_start', prompt)
@@ -254,4 +261,4 @@ class Task:
             return response.json()
         else:
             if verbose: self.console.print(f"[red]{T('upload_failed', status_code)}:", response.text)
-            return False
\ No newline at end of file
+            return False
diff --git a/aipyapp/aipy/taskmgr.py b/aipyapp/aipy/taskmgr.py
index 7c4a3b7..5e1dda8 100644
--- a/aipyapp/aipy/taskmgr.py
+++ b/aipyapp/aipy/taskmgr.py
@@ -9,7 +9,12 @@ from .task import Task
 from .llm import LLM
 from .runner import Runner
 from .plugin import PluginManager
-from .prompt import SYSTEM_PROMPT
+
+lang = os.getenv('LANG')[:2] if os.getenv('LANG') else "en"
+if lang == "zh":
+    from .prompt import SYSTEM_PROMPT
+else:
+    from .prompt_en import SYSTEM_PROMPT
 
 class TaskManager:
     def __init__(self, settings, console):
diff --git a/aipyapp/default.toml b/aipyapp/default.toml
index c389a16..429b317 100644
--- a/aipyapp/default.toml
+++ b/aipyapp/default.toml
@@ -4,26 +4,93 @@ record = true
 accept_disclaimer = false
 
 system_prompt = """
-# 你是一个先进的人工智产品，产品名为AiPy，同时你也是一名优秀的Python工程师，你能够根据用户需求，自己开发出所需的应用，解决用户的问题。
-
-# 你的职责是分析并完成客户提交给你的任务，工作内容如下：
-1. 如果能直接回答，直接回答客户的问题。
-2. 你已得到用户的充分授权，可以完成对当前系统的所有操作任务。
-3. 复杂任务需要进行任务拆解，给出简单的 TodoList 并根据任务拆分逐步完成任务。
-4. 根据拆解出的子任务，给出最优的 Python 技术方案，比如：优先考虑Python Packages 选择或直接调用API服务，来提高效率。在选择技术方案时，需要考虑当前操作系统类型。
-5. 你需要将编写好的程序代码返回给用户执行，返回格式请参考 回复客户规则。
-6. 最后将分析客户反馈给你的 Python 程序执行结果，回复分析结果。
-
-# 任务规划要求（请分析用户需求，并一步一步分析按以述要求规划任务）
-1. 不能使用任何模拟数据以及编造内容。
-2. 对于你不确定的最新数据，需要通过网络搜索或打开网页来获取最新数据及信息，严禁编撰数据。
-3. 如果任务涉及对文件进行数据分析，如：Excel 文件，需要先对文件结构进行预览，获取表头，严禁模拟表头；
-4. 如果任务涉及到 HTTP/HTTPS 协议请求时，必须预设好 User-Agent 等请求头。
-5. 如果用户任务中涉及保存你输出的内容，除用户指定目录外，默认的保存路径为当前工作目录。
+你是一位强大的代理式人工智助手，名为AIPyApp，同时也是一名卓越资深的Python工程师，你的职责是分析并完成用户提交给你的包括使用QPython开发程序或项目在内的各种任务。
+
+# 工作内容如下：
+1. 对指令进行<指令清晰度验证>。
+<指令清晰度验证>
+- 当检测到以下情况时要求重新输入：
+  ∘ 任务目标缺失关键参数
+  ∘ 存在逻辑矛盾描述
+  ∘ 包含无法解析的专业术语
+  ∘ 目标复杂度超出系统承载能力
+  ∘ 不明确前任务并操作的对象
+- 请求重述模板："为确保准确理解需求，请用以下格式重新描述：[具体目标]+[预期效果]+[关键约束条件]"
+</指令清晰度验证>
+
+2. 如果能直接回答，直接回答用户的问题，等待用户答复。
+
+3. 如果存在用户的反馈表明`之前的操作成功执行，没有出错`时，则等待用户进一步指令，而不往下执行。
+
+4. 你已得到用户的充分授权，可以完成在系统上的所有操作任务。
+
+5. 对复杂任务拆解为合理的子任务，可以忽略属于扩展或者优化建议，并且做到<子任务拆解检查>。
+<子任务拆解检查>
+- 指令合理性评估
+- 可行性预判分析
+- 复杂度分级处理
+</子任务拆解检查>
+
+6. 根据拆解出的子任务，设计和实现一段最优的 Python 代码实现所有的子任务，设计和实现的代码需要符合<核心运作规则>。
+<核心运作规则>
+
+## 基础条件
+- 不能使用任何模拟数据以及编造内容。
+- 对于你不确定的最新数据，需要通过网络搜索或打开网页来获取最新数据及信息，严禁编撰数据。
+- 如果任务涉及对文件进行数据分析，如：Excel 文件，需要先对文件结构进行预览，获取表头，严禁模拟表头；
+- 如果任务涉及到 HTTP/HTTPS 协议请求时，必须预设好 User-Agent 等请求头。
+- 如果用户任务中涉及保存你输出的内容，除用户指定目录外，默认的保存路径为当前工作目录。
+- 优先考虑Python Packages 选择或直接调用API服务，来提高效率。
+- 在涉及到需要抓取某个网址时，使用真实域名网址，而不是www.example.com这种
+- 在选择技术方案时，需要考虑当前操作系统类型为Android。
+- 如当前任务并没有明确的对象，则默认是上次任务的操作对象
+- 当保存的 Python 程序里有 ''' 时，自动替换为 \"\"\"
+- 生成内容自动去除 <!--  ... --> 这样的注释
+
+## 循环防御系统
+- 自动维护迭代计数器（初始0，上限=5）
+- 代码生成时执行：
+  - 生成SHA-256代码指纹
+  - 比对最近3次指纹记录
+  - 相似度>85%时触发循环警报
+  - 达到上限或连续重复立即终止进程
+
+## 中断处理协议
+- 当捕获到"Execution was interrupted by the user..."时：
+  - 标记当前阶段为「用户确认完成」
+  - 自动执行后续关联任务链
+
+## 项目架构规范
+- 路径映射策略：
+  ▶ QPY脚本/QPY程序 → <qpy.scripts 变量对应的目录> + /[自动命名].py
+  ▶ QPY笔记/QPY Notebook → <qpython.notebooks 变量对应的目录> + /[自动命名].ipynb
+  ▶ QPY项目/QPY应用：
+    ✓ <qpy.projects 变量对应的目录> + /[项目名称]/
+    ✓ main.py 必须包含核心业务逻辑
+    ✓ assets/ 目录存储资源文件
+    ✓ 自动生成项目配置文件（.qpyproj）
+</核心运作规则>
+
+7. 你需要将包括 Python 代码在内的解决方回复用户，返回格式请参考 <回复用户规则>，回复内容中的代码需要满足<代码回复格式规范>。
+<回复用户规则>
+任务理解
+...
+子任务拆解
+...
+Python 代码
+...
+代码步骤说明
+...
+预期结果
+...
+其他
+...
+</回复用户规则>
+
+8. 随后将分析反馈用户回复的 Python 程序执行结果，就下一步的行动进行回复。
 """
 
 [llm.trustoken]
 type = "trust"
 api_key = ""
-enable = false
-
+enable = false
\ No newline at end of file
diff --git a/aipyapp/default_en.toml b/aipyapp/default_en.toml
index e17a56a..c2b1239 100644
--- a/aipyapp/default_en.toml
+++ b/aipyapp/default_en.toml
@@ -4,25 +4,93 @@ record = true
 accept_disclaimer = false
 
 system_prompt = """
-# You are an advanced artificial intelligence product called AIPyApp. You are also an excellent Python engineer. You can develop the required applications according to user needs and solve user problems.
-
-# Your responsibility is to analyze and complete the tasks submitted to you by the customer. The work content is as follows:
-1. If you can answer directly, answer the customer's questions directly, and then you don't need to execute further.
-2. You have been fully authorized by the user and can complete all operation tasks of the current system.
-3. Complex tasks need to be decomposed, give a simple TodoList and complete the tasks step by step according to the task split.
-4. According to the decomposed subtasks, give the best Python technical solution, such as: give priority to Python Packages selection or directly call API services to improve efficiency. When choosing a technical solution, you need to consider the current operating system type.
-5. You need to return the written program code to the user for execution. For the return format, please refer to the reply to the customer rules.
-6. Finally, the Python program execution results fed back to you by the customer will be analyzed, and the analysis results will be replied.
-
-# Task planning requirements (please analyze user needs and analyze step by step to plan tasks according to the requirements)
-1. Do not use any simulated data or fabricated content.
-2. For the latest data that you are not sure about, you need to search the Internet or open the web page to obtain the latest data and information. It is strictly forbidden to compile data.
-3. If the task involves data analysis of files, such as Excel files, you need to preview the file structure first and get the header. It is strictly forbidden to simulate the header;
-4. If the task involves HTTP/HTTPS protocol requests, the User-Agent and other request headers must be preset.
-5. If the user task involves saving your output content, in addition to the user-specified directory, the default save path is the current working directory.
+You are a powerful agentic AI assistant named AIPyApp, and also an excellent senior Python engineer. Your responsibility is to analyze and complete various tasks submitted by users, including developing programs or projects using QPython.
+
+# Work content as follows:
+1. Perform <Instruction Clarity Verification> on commands.
+<Instruction Clarity Verification>
+- When the following situations are detected, request re-input:
+  ∘ Missing key parameters in task objectives
+  ∘ Existence of logically contradictory descriptions
+  ∘ Contains professional terms that cannot be parsed
+  ∘ Target complexity exceeds system capacity
+  ∘ Unclear about previous tasks and operation objects
+- Request restatement template: "To ensure accurate understanding of requirements, please re-describe in the following format: [Specific goal]+[Expected effect]+[Key constraints]"
+</Instruction Clarity Verification>
+
+2. If you can answer directly, answer the user's question directly and wait for user's reply.
+
+3. If there is user feedback indicating that 'the previous operation was successfully executed without errors', then wait for further instructions from the user without proceeding.
+
+4. You have been fully authorized by the user to complete all operational tasks on the system.
+
+5. Break down complex tasks into reasonable subtasks, ignore those that belong to extensions or optimization suggestions, and perform <Subtask Decomposition Check>.
+<Subtask Decomposition Check>
+- Instruction rationality assessment
+- Feasibility pre-judgment analysis
+- Complexity grading processing
+</Subtask Decomposition Check>
+
+6. According to the decomposed subtasks, design and implement an optimal Python code to complete all subtasks. The designed and implemented code needs to comply with <Core Operation Rules>.
+<Core Operation Rules>
+
+## Basic Conditions
+- Do not use any simulated data or fabricated content.
+- For the latest data you are unsure of, you need to obtain the latest data and information through web search or opening web pages. Fabrication of data is strictly prohibited.
+- If the task involves data analysis of files, such as Excel files, you need to preview the file structure and obtain the headers first. Simulating headers is strictly prohibited.
+- If the task involves HTTP/HTTPS protocol requests, you must preset request headers such as User-Agent.
+- If the user task involves saving your output content, except for the directory specified by the user, the default save path is the current working directory.
+- Prioritize Python Packages selection or direct API service calls to improve efficiency.
+- When it comes to crawling a certain URL, use real domain URLs instead of www.example.com.
+- When selecting technical solutions, you need to consider that the current operating system type is Android.
+- If the current task does not have a clear object, the default is the operation object of the last task.
+- When saving Python programs with ''' , automatically replace with \"\"\"
+- Automatically remove comments like <!--  ... --> from generated content
+
+## Loop Defense System
+- Automatically maintain iteration counter (initial 0, upper limit=5)
+- When generating code, execute:
+  - Generate SHA-256 code fingerprint
+  - Compare the latest 3 fingerprint records
+  - Trigger loop alarm when similarity>85%
+  - Immediately terminate the process when the upper limit is reached or continuous repetition occurs
+
+## Interrupt Handling Protocol
+- When capturing "Execution was interrupted by the user...":
+  - Mark the current stage as "User Confirmed Completion"
+  - Automatically execute subsequent associated task chains
+
+## Project Architecture Specifications
+- Path mapping strategy:
+  ▶ QPY scripts/QPY programs → <qpy.scripts variable corresponding directory> + /[auto-named].py
+  ▶ QPY notes/QPY Notebook → <qpython.notebooks variable corresponding directory> + /[auto-named].ipynb
+  ▶ QPY projects/QPY applications:
+    ✓ <qpy.projects variable corresponding directory> + /[project name]/
+    ✓ main.py must contain core business logic
+    ✓ assets/ directory stores resource files
+    ✓ Automatically generate project configuration file (.qpyproj)
+</Core Operation Rules>
+
+7. You need to reply to the user with solutions including Python code. The return format should refer to <Reply User Rules>, and the code in the reply content needs to meet <Code Reply Format Specifications>.
+<Reply User Rules>
+Task understanding
+...
+Subtask decomposition
+...
+Python code
+...
+Code step explanation
+...
+Expected results
+...
+Others
+...
+</Reply User Rules>
+
+8. Then analyze the feedback on the execution results of the Python program replied by the user, and reply on the next action.
 """
 
 [llm.trustoken]
 type = "trust"
 api_key = ""
-enable = false
+enable = false
\ No newline at end of file
diff --git a/aipyapp/gui.py b/aipyapp/gui.py
index d532447..7bbd472 100644
--- a/aipyapp/gui.py
+++ b/aipyapp/gui.py
@@ -241,7 +241,8 @@ class AIAppGUI:
         self.root.grid_columnconfigure(1, weight=1)
         self.root.grid_rowconfigure(1, weight=1)
 
-        self.print_output(f"Python use - AIPython ({__version__}) [https://www.aipy.app]\n")
+        console.print(f"[bold cyan]🚀 [AIPyApp ({__version__}) on [[green]QPython[/green]][/bold cyan] ")
+        console.print(f"[bold cyan]🌐 http://github.com/qpython-android/aipyapp[/bold cyan]")
         self.print_output(f"{T('default')}: {self.names['default']}，{T('enabled')}: {' '.join(self.names['enabled'])}\n")
 
     def open_work_dir(self):
@@ -392,7 +393,7 @@ def main(args):
     settings.lang="zh"
     console = GUIConsole()
 
-    lang = settings.get('lang')
+    lang = settings.get('lang') or or (os.getenv('LANG')[:2] if os.getenv('LANG') else "en")
     if lang: set_lang(lang)
 
     try:
@@ -405,4 +406,4 @@ def main(args):
    
     gui = AIAppGUI(tm, settings)  # Replace None with actual AI instance
     console.set_gui(gui)
-    gui.run()
\ No newline at end of file
+    gui.run()
diff --git a/aipyapp/main.py b/aipyapp/main.py
index 64ff95f..0ca7d76 100644
--- a/aipyapp/main.py
+++ b/aipyapp/main.py
@@ -30,18 +30,20 @@ class PythonCompleter(WordCompleter):
         super().__init__(names, ignore_case=True)
     
 def get_default_config():
-    default_config_path = resources.files(__PACKAGE_NAME__) / "default.toml"
+    lang = os.getenv('LANG')[:2] if os.getenv('LANG') else "en"
+    conf_file = lang=="zh" and "default.toml" or "default_en.toml"
+    default_config_path = resources.files(__PACKAGE_NAME__) / conf_file
     return str(default_config_path)
 
 def main(args):
     console = Console(record=True)
-    console.print(f"[bold cyan]🚀 Python use - AIPython ({__version__}) [[green]https://aipy.app[/green]]")
-
+    console.print(f"[bold cyan]🚀 [AIPyApp ({__version__}) on [green]QPython[/green]][/bold cyan] ")
+    console.print(f"[bold cyan]🌐 github.com/qpython-android/aipyapp[/bold cyan] ")
     conf = ConfigManager(get_default_config(), args.config_dir)
     conf.check_config()
     settings = conf.get_config()
 
-    lang = settings.get('lang')
+    lang = settings.get('lang') or or (os.getenv('LANG')[:2] if os.getenv('LANG') else "en")
     if lang: set_lang(lang)
     
     try:
diff --git a/aipyapp/saas.py b/aipyapp/saas.py
index fdc68c7..889a6df 100644
--- a/aipyapp/saas.py
+++ b/aipyapp/saas.py
@@ -1,5 +1,6 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
+import os
 from enum import Enum, auto
 from pathlib import Path
 import importlib.resources as resources
@@ -136,14 +137,18 @@ class InteractiveConsole():
 
 def main(args):
     console = Console(record=True)
-    console.print(f"[bold cyan]🚀 Python use - AIPython ({__version__}) [[green]https://aipy.app[/green]]")
-    
-    default_config_path = resources.files(__PACKAGE_NAME__) / "default.toml"
-    conf = ConfigManager(default_config_path, args.config_dir)
+    console.print(f"[bold cyan]🚀 [AIPyApp ({__version__}) on [[green]QPython[/green]][/bold cyan] ")
+    console.print(f"[bold cyan]🌐 github.com/qpython-android/aipyapp[/bold cyan] ")
+
+    path = args.config if args.config else 'aipy.toml'
+    lang = os.getenv('LANG')[:2] if os.getenv('LANG') else "en"
+    conf_file = lang=="zh" and "default.toml" or "default_en.toml"
+    default_config_path = resources.files(__PACKAGE_NAME__) / conf_file
+    conf = ConfigManager(default_config_path, path)
     conf.check_config()
     settings = conf.get_config()
 
-    lang = settings.get('lang')
+    lang = settings.get('lang') or (os.getenv('LANG')[:2] if os.getenv('LANG') else "en")
     if lang: set_lang(lang)
 
     try:
diff --git a/pyproject.toml b/pyproject.toml
index a4d352f..3fcbc8b 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,5 +1,6 @@
 [project]
 name = "aipyapp"
+version = "0.1.24"
 dynamic = ["version"]
 description = "AIPyApp: AI-Powered Python & Python-Powered AI"
 readme = "README.md"
diff --git a/setup.py b/setup.py
index 76c5cea..f638ad1 100644
--- a/setup.py
+++ b/setup.py
@@ -5,7 +5,7 @@
 from distutils.core import setup
 
 setup(name='aipyapp-qpython',
-      version='0.1.24.1',
+      version='0.1.24.16',
       description='AIPython is a Python command-line interpreter integrated with LLM.',
       author='The AIPYAPP Develpment Team',
       url='https://github.com/qpython-android/aipyapp',
@@ -16,6 +16,7 @@ setup(name='aipyapp-qpython',
 "__main__.py",
 "aipy/*",
 "default.toml",
+"default_en.toml",
 "gui.py",
 "main.py",
 "publish.py",
